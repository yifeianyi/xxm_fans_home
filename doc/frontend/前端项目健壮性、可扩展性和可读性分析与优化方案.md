# XXM Fans Home å‰ç«¯é¡¹ç›®å¥å£®æ€§ã€å¯æ‰©å±•æ€§å’Œå¯è¯»æ€§åˆ†æä¸ä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

æœ¬æŠ¥å‘Šå¯¹ XXM Fans Home å‰ç«¯é¡¹ç›®è¿›è¡Œäº†å…¨é¢çš„ä»£ç è´¨é‡è¯„ä¼°ï¼Œæ¶µç›–å¥å£®æ€§ã€å¯æ‰©å±•æ€§å’Œå¯è¯»æ€§ä¸‰ä¸ªç»´åº¦ã€‚é¡¹ç›®é‡‡ç”¨ DDDï¼ˆé¢†åŸŸé©±åŠ¨è®¾è®¡ï¼‰æ¶æ„ï¼Œå…·æœ‰è‰¯å¥½çš„åˆ†å±‚è®¾è®¡åŸºç¡€ï¼Œä½†åœ¨æµ‹è¯•è¦†ç›–ç‡ã€é”™è¯¯å¤„ç†ã€æ€§èƒ½ä¼˜åŒ–ã€ä»£ç è§„èŒƒç­‰æ–¹é¢å­˜åœ¨æ”¹è¿›ç©ºé—´ã€‚

### æ ¸å¿ƒå‘ç°

| ç»´åº¦ | è¯„åˆ† | å…³é”®é—®é¢˜ | ä¼˜å…ˆçº§ |
|------|------|----------|--------|
| **å¥å£®æ€§** | 6/10 | æµ‹è¯•è¦†ç›–ç‡ä½ã€é”™è¯¯å¤„ç†ä¸ç»Ÿä¸€ã€ç¼ºå°‘æ—¥å¿—ç³»ç»Ÿ | ğŸ”´ é«˜ |
| **å¯æ‰©å±•æ€§** | 7/10 | ç¼ºå°‘çŠ¶æ€ç®¡ç†ã€æ€§èƒ½ä¼˜åŒ–ä¸è¶³ã€é…ç½®åˆ†æ•£ | ğŸŸ¡ ä¸­ |
| **å¯è¯»æ€§** | 7/10 | ç»„ä»¶å¤æ‚åº¦é«˜ã€æ–‡æ¡£ä¸å®Œæ•´ã€ä»£ç é£æ ¼ä¸ä¸€è‡´ | ğŸŸ¡ ä¸­ |

---

## ä¸€ã€å¥å£®æ€§åˆ†æ

### 1.1 æµ‹è¯•è¦†ç›–ç‡ âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
- âŒ ç¼ºå°‘å•å…ƒæµ‹è¯•ï¼ˆJest/Vitestï¼‰
- âŒ ç¼ºå°‘ç»„ä»¶æµ‹è¯•ï¼ˆReact Testing Libraryï¼‰
- âŒ ç¼ºå°‘E2Eæµ‹è¯•ï¼ˆPlaywright/Cypressï¼‰
- âœ… å­˜åœ¨APIæµ‹è¯•è„šæœ¬ï¼ˆä½†æœªé›†æˆåˆ°CIï¼‰

**é—®é¢˜åˆ†æï¼š**
```bash
test/
â”œâ”€â”€ analyze-api-formats.js      # APIæ ¼å¼åˆ†æè„šæœ¬
â”œâ”€â”€ check-cors.js               # CORSæ£€æŸ¥
â”œâ”€â”€ simple-test.js              # ç®€å•APIæµ‹è¯•
â””â”€â”€ test-all-apis.js            # APIé›†æˆæµ‹è¯•
```

ä»…æœ‰æ‰‹åŠ¨æµ‹è¯•è„šæœ¬ï¼Œæ— æ³•è‡ªåŠ¨åŒ–éªŒè¯ä»£ç å˜æ›´ã€‚

**å½±å“ï¼š**
- ä»£ç é‡æ„é£é™©é«˜ï¼Œå®¹æ˜“å¼•å…¥å›å½’bug
- æ–°åŠŸèƒ½å¼€å‘æ— æ³•ä¿è¯è´¨é‡
- ç¼ºå°‘å¿«é€Ÿåé¦ˆæœºåˆ¶

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 1.1.1 å¼•å…¥å•å…ƒæµ‹è¯•æ¡†æ¶
```json
// package.json
{
  "devDependencies": {
    "vitest": "^2.0.0",
    "@vitest/ui": "^2.0.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.0.0",
    "@testing-library/user-event": "^14.0.0"
  },
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  }
}
```

#### 1.1.2 æµ‹è¯•ç›®å½•ç»“æ„
```
repo/xxm_fans_frontend/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ __tests__/
â”‚   â”œâ”€â”€ unit/                    # å•å…ƒæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ services/            # æœåŠ¡å±‚æµ‹è¯•
â”‚   â”‚   â”‚   â””â”€â”€ RealSongService.test.ts
â”‚   â”‚   â”œâ”€â”€ utils/               # å·¥å…·å‡½æ•°æµ‹è¯•
â”‚   â”‚   â”‚   â””â”€â”€ index.test.ts
â”‚   â”‚   â””â”€â”€ hooks/               # Hooksæµ‹è¯•
â”‚   â”‚       â””â”€â”€ useSongData.test.ts
â”‚   â”œâ”€â”€ integration/             # é›†æˆæµ‹è¯•
â”‚   â”‚   â””â”€â”€ api/                 # APIé›†æˆæµ‹è¯•
â”‚   â”‚       â””â”€â”€ songs.test.ts
â”‚   â””â”€â”€ components/              # ç»„ä»¶æµ‹è¯•
â”‚       â”œâ”€â”€ features/
â”‚       â”‚   â””â”€â”€ SongTable.test.tsx
â”‚       â””â”€â”€ common/
â”‚           â””â”€â”€ ErrorBoundary.test.tsx
â”œâ”€â”€ vitest.config.ts
â””â”€â”€ coverage/                    # è¦†ç›–ç‡æŠ¥å‘Š
```

#### 1.1.3 ç¤ºä¾‹æµ‹è¯•ç”¨ä¾‹
```typescript
// __tests__/unit/services/RealSongService.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { RealSongService } from '../../infrastructure/api/RealSongService';
import { ApiError } from '../../infrastructure/api/apiTypes';

describe('RealSongService', () => {
  let service: RealSongService;
  let mockFetch: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    service = new RealSongService();
    mockFetch = vi.fn();
    global.fetch = mockFetch;
  });

  describe('getSongs', () => {
    it('åº”è¯¥æˆåŠŸè·å–æ­Œæ›²åˆ—è¡¨', async () => {
      const mockResponse = {
        code: 200,
        message: 'success',
        data: {
          total: 10,
          page: 1,
          page_size: 50,
          results: [
            {
              id: '1',
              song_name: 'æµ‹è¯•æ­Œæ›²',
              singer: 'æµ‹è¯•æ­Œæ‰‹',
              styles: ['æµè¡Œ'],
              tags: ['æµ‹è¯•'],
              language: 'ä¸­æ–‡'
            }
          ]
        }
      };

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: () => Promise.resolve(mockResponse)
      });

      const result = await service.getSongs({ page: 1 });

      expect(result.error).toBeUndefined();
      expect(result.data).toBeDefined();
      expect(result.data?.results).toHaveLength(1);
      expect(result.data?.results[0].name).toBe('æµ‹è¯•æ­Œæ›²');
    });

    it('åº”è¯¥å¤„ç†APIé”™è¯¯', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        statusText: 'Not Found'
      });

      const result = await service.getSongs({ page: 1 });

      expect(result.data).toBeUndefined();
      expect(result.error).toBeInstanceOf(ApiError);
      expect(result.error?.status).toBe(500);
    });
  });
});
```

#### 1.1.4 æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡
- **è¯­å¥è¦†ç›–ç‡**: â‰¥ 80%
- **åˆ†æ”¯è¦†ç›–ç‡**: â‰¥ 75%
- **å‡½æ•°è¦†ç›–ç‡**: â‰¥ 80%
- **è¡Œè¦†ç›–ç‡**: â‰¥ 80%

---

### 1.2 é”™è¯¯å¤„ç† âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// ç°æœ‰é”™è¯¯å¤„ç†æ¨¡å¼
try {
  const result = await songService.getSongs(params);
  if (result.error) {
    console.error('è·å–æ­Œæ›²å¤±è´¥:', result.error);
  }
} catch (error) {
  console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
}
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ é”™è¯¯å¤„ç†ä¸ç»Ÿä¸€ï¼šæœ‰äº›åœ°æ–¹æœ‰try-catchï¼Œæœ‰äº›æ²¡æœ‰
2. âŒ é”™è¯¯ä¿¡æ¯ä»…æ‰“å°åˆ°æ§åˆ¶å°ï¼Œç”¨æˆ·æ— æ„ŸçŸ¥
3. âŒ ç¼ºå°‘é”™è¯¯åˆ†ç±»å’Œé™çº§æ–¹æ¡ˆ
4. âŒ ç¼ºå°‘é”™è¯¯ä¸ŠæŠ¥æœºåˆ¶
5. âŒ ErrorBoundaryè¦†ç›–èŒƒå›´æœ‰é™

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 1.2.1 ç»Ÿä¸€é”™è¯¯å¤„ç†å±‚
```typescript
// infrastructure/error/ErrorHandler.ts
export enum ErrorLevel {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical'
}

export enum ErrorCategory {
  NETWORK = 'network',
  API = 'api',
  VALIDATION = 'validation',
  UI = 'ui',
  UNKNOWN = 'unknown'
}

export interface AppError {
  level: ErrorLevel;
  category: ErrorCategory;
  message: string;
  code?: string;
  stack?: string;
  timestamp: number;
  context?: Record<string, any>;
}

class ErrorHandler {
  private errors: AppError[] = [];
  private maxErrors = 100;

  handleError(error: Error | AppError | unknown, category: ErrorCategory = ErrorCategory.UNKNOWN, context?: Record<string, any>): void {
    const appError: AppError = this.normalizeError(error, category, context);
    
    // å­˜å‚¨é”™è¯¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    this.errors.push(appError);
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }

    // æ ¹æ®çº§åˆ«å¤„ç†
    switch (appError.level) {
      case ErrorLevel.CRITICAL:
        this.handleCriticalError(appError);
        break;
      case ErrorLevel.ERROR:
        this.handleError(appError);
        break;
      case ErrorLevel.WARNING:
        this.handleWarning(appError);
        break;
      default:
        this.handleInfo(appError);
    }

    // ä¸ŠæŠ¥åˆ°ç›‘æ§ç³»ç»Ÿ
    this.reportToMonitor(appError);
  }

  private normalizeError(error: unknown, category: ErrorCategory, context?: Record<string, any>): AppError {
    if (this.isAppError(error)) {
      return error;
    }

    if (error instanceof Error) {
      return {
        level: this.determineErrorLevel(error),
        category,
        message: error.message,
        stack: error.stack,
        timestamp: Date.now(),
        context
      };
    }

    return {
      level: ErrorLevel.WARNING,
      category,
      message: String(error),
      timestamp: Date.now(),
      context
    };
  }

  private determineErrorLevel(error: Error): ErrorLevel {
    // æ ¹æ®é”™è¯¯ç±»å‹åˆ¤æ–­çº§åˆ«
    if (error.name === 'ApiError') return ErrorLevel.ERROR;
    if (error.name === 'NetworkError') return ErrorLevel.WARNING;
    return ErrorLevel.ERROR;
  }

  private handleCriticalError(error: AppError): void {
    // ä¸¥é‡é”™è¯¯ï¼šæ˜¾ç¤ºé”™è¯¯é¡µé¢ï¼Œé˜»æ­¢æ“ä½œ
    console.error('ğŸ”´ CRITICAL ERROR:', error);
    // å¯ä»¥è§¦å‘å…¨å±€é”™è¯¯çŠ¶æ€
  }

  private handleError(error: AppError): void {
    // ä¸€èˆ¬é”™è¯¯ï¼šæ˜¾ç¤ºé”™è¯¯æç¤º
    console.error('âŒ ERROR:', error);
    // å¯ä»¥è§¦å‘Toasté€šçŸ¥
  }

  private handleWarning(error: AppError): void {
    // è­¦å‘Šï¼šè®°å½•æ—¥å¿—ï¼Œä¸å½±å“ç”¨æˆ·æ“ä½œ
    console.warn('âš ï¸ WARNING:', error);
  }

  private handleInfo(error: AppError): void {
    // ä¿¡æ¯ï¼šä»…è®°å½•
    console.info('â„¹ï¸ INFO:', error);
  }

  private reportToMonitor(error: AppError): void {
    // ä¸ŠæŠ¥åˆ°ç›‘æ§ç³»ç»Ÿï¼ˆå¦‚Sentryã€LogRocketï¼‰
    if (import.meta.env.PROD) {
      // sentry.captureException(error);
    }
  }

  private isAppError(error: unknown): error is AppError {
    return typeof error === 'object' && error !== null && 'level' in error;
  }

  getErrors(): AppError[] {
    return [...this.errors];
  }

  clearErrors(): void {
    this.errors = [];
  }
}

export const errorHandler = new ErrorHandler();
```

#### 1.2.2 è‡ªå®šä¹‰React Hooks
```typescript
// presentation/hooks/useErrorHandler.ts
import { useState, useCallback } from 'react';
import { errorHandler, ErrorLevel, ErrorCategory } from '../../infrastructure/error/ErrorHandler';

interface UseErrorHandlerReturn {
  error: string | null;
  isError: boolean;
  clearError: () => void;
  handleError: (error: unknown, category?: ErrorCategory, context?: Record<string, any>) => void;
}

export const useErrorHandler = (): UseErrorHandlerReturn => {
  const [error, setError] = useState<string | null>(null);

  const handleError = useCallback((err: unknown, category: ErrorCategory = ErrorCategory.UNKNOWN, context?: Record<string, any>) => {
    errorHandler.handleError(err, category, context);
    
    // æå–é”™è¯¯ä¿¡æ¯
    let errorMessage = 'æ“ä½œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    if (err instanceof Error) {
      errorMessage = err.message;
    } else if (typeof err === 'string') {
      errorMessage = err;
    }

    setError(errorMessage);

    // 3ç§’åè‡ªåŠ¨æ¸…é™¤é”™è¯¯
    setTimeout(() => {
      setError(null);
    }, 3000);
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    error,
    isError: error !== null,
    handleError,
    clearError
  };
};
```

#### 1.2.3 ä½¿ç”¨ç¤ºä¾‹
```typescript
// presentation/pages/SongsPage.tsx
import { useErrorHandler } from '../hooks/useErrorHandler';

const SongsPage: React.FC = () => {
  const { error, isError, handleError, clearError } = useErrorHandler();
  const [songs, setSongs] = useState<Song[]>([]);

  const loadSongs = async () => {
    try {
      const result = await songService.getSongs({ page: 1 });
      
      if (result.error) {
        handleError(result.error, ErrorCategory.API, { page: 1 });
        return;
      }

      setSongs(result.data?.results || []);
    } catch (err) {
      handleError(err, ErrorCategory.NETWORK);
    }
  };

  return (
    <div>
      {isError && (
        <div className="error-banner">
          <span>{error}</span>
          <button onClick={clearError}>å…³é—­</button>
        </div>
      )}
      {/* é¡µé¢å†…å®¹ */}
    </div>
  );
};
```

---

### 1.3 æ—¥å¿—ç³»ç»Ÿ âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// å¤§é‡ä½¿ç”¨console.log
console.log('[GalleryPage] å¼€å§‹åŠ è½½å›¾ç‰‡:', galleryId);
console.error('è·å–ç›´æ’­è¯¦æƒ…å¤±è´¥:', error);
console.warn('âš ï¸ API è¿”å›æ— æ•°æ®ä¸”æ— é”™è¯¯');
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ æ—¥å¿—æ ¼å¼ä¸ç»Ÿä¸€
2. âŒ ç”Ÿäº§ç¯å¢ƒæ— æ³•å…³é—­æ—¥å¿—
3. âŒ ç¼ºå°‘æ—¥å¿—åˆ†çº§å’Œç»“æ„åŒ–
4. âŒ æ— æ³•è¿œç¨‹æ”¶é›†æ—¥å¿—
5. âŒ ç¼ºå°‘æ—¥å¿—è¿½è¸ªï¼ˆrequestIdï¼‰

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 1.3.1 ç»“æ„åŒ–æ—¥å¿—ç³»ç»Ÿ
```typescript
// shared/utils/logger.ts
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  FATAL = 4
}

export interface LogEntry {
  level: LogLevel;
  timestamp: number;
  message: string;
  context?: Record<string, any>;
  requestId?: string;
  userId?: string;
}

class Logger {
  private currentLevel = LogLevel.INFO;
  private logs: LogEntry[] = [];
  private maxLogs = 500;
  private requestId?: string;

  setRequestId(requestId: string): void {
    this.requestId = requestId;
  }

  setLevel(level: LogLevel): void {
    this.currentLevel = level;
  }

  private log(level: LogLevel, message: string, context?: Record<string, any>): void {
    if (level < this.currentLevel) return;

    const entry: LogEntry = {
      level,
      timestamp: Date.now(),
      message,
      context,
      requestId: this.requestId
    };

    this.logs.push(entry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }

    // æ ¼å¼åŒ–è¾“å‡º
    const levelName = LogLevel[level];
    const time = new Date(entry.timestamp).toISOString();
    const prefix = `[${time}] [${levelName}] ${this.requestId ? `[${this.requestId}]` : ''}`;

    switch (level) {
      case LogLevel.DEBUG:
      case LogLevel.INFO:
        console.log(prefix, message, context || '');
        break;
      case LogLevel.WARN:
        console.warn(prefix, message, context || '');
        break;
      case LogLevel.ERROR:
      case LogLevel.FATAL:
        console.error(prefix, message, context || '');
        break;
    }

    // ä¸ŠæŠ¥åˆ°æ—¥å¿—æœåŠ¡ï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰
    if (import.meta.env.PROD && level >= LogLevel.ERROR) {
      this.uploadLog(entry);
    }
  }

  debug(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.DEBUG, message, context);
  }

  info(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.INFO, message, context);
  }

  warn(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.WARN, message, context);
  }

  error(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.ERROR, message, context);
  }

  fatal(message: string, context?: Record<string, any>): void {
    this.log(LogLevel.FATAL, message, context);
  }

  getLogs(): LogEntry[] {
    return [...this.logs];
  }

  clearLogs(): void {
    this.logs = [];
  }

  private async uploadLog(entry: LogEntry): Promise<void> {
    try {
      await fetch('/api/logs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(entry)
      });
    } catch (error) {
      // é™é»˜å¤±è´¥ï¼Œé¿å…æ­»å¾ªç¯
    }
  }
}

export const logger = new Logger();

// æ ¹æ®ç¯å¢ƒè®¾ç½®æ—¥å¿—çº§åˆ«
if (import.meta.env.DEV) {
  logger.setLevel(LogLevel.DEBUG);
} else {
  logger.setLevel(LogLevel.INFO);
}
```

#### 1.3.2 ä½¿ç”¨ç¤ºä¾‹
```typescript
// æ›¿æ¢åŸæœ‰çš„console.log
logger.info('[GalleryPage] å¼€å§‹åŠ è½½å›¾ç‰‡', { galleryId });
logger.error('[GalleryPage] å›¾ç‰‡åŠ è½½å¤±è´¥', { galleryId, error });
logger.debug('[GalleryPage] å›¾ç‰‡æ•°æ®è§£æ', { data });
```

---

### 1.4 APIè¯·æ±‚å¥å£®æ€§ âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// infrastructure/api/RealSongService.ts
private async request<T>(endpoint: string, options?: RequestInit): Promise<ApiResult<T>> {
  try {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new ApiError(response.status, `Request failed: ${response.statusText}`);
    }
    // ...
  } catch (error) {
    if (error instanceof ApiError) {
      return { error };
    }
    return { error: new ApiError(500, 'Network error') };
  }
}
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ ç¼ºå°‘è¯·æ±‚é‡è¯•æœºåˆ¶
2. âŒ ç¼ºå°‘è¯·æ±‚å–æ¶ˆï¼ˆAbortControllerï¼‰
3. âŒ ç¼ºå°‘è¯·æ±‚ç¼“å­˜
4. âŒ ç¼ºå°‘è¯·æ±‚è¶…æ—¶æ§åˆ¶
5. âŒ ç¼ºå°‘å¹¶å‘è¯·æ±‚é™åˆ¶

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 1.4.1 å¢å¼ºAPIå®¢æˆ·ç«¯
```typescript
// infrastructure/api/EnhancedApiClient.ts
export interface RequestConfig extends RequestInit {
  retries?: number;
  timeout?: number;
  cache?: boolean;
  priority?: 'high' | 'normal' | 'low';
}

class EnhancedApiClient {
  private baseURL = config.api.baseURL;
  private cache = new Map<string, { data: any; timestamp: number }>();
  private cacheDuration = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  private pendingRequests = new Map<string, Promise<any>>();
  private maxConcurrent = 6;
  private activeRequests = 0;

  async request<T>(endpoint: string, config: RequestConfig = {}): Promise<ApiResult<T>> {
    const {
      retries = 2,
      timeout = 10000,
      cache: enableCache = false,
      priority = 'normal',
      ...fetchOptions
    } = config;

    const url = `${this.baseURL}${endpoint}`;
    const cacheKey = `${url}_${JSON.stringify(fetchOptions)}`;

    // æ£€æŸ¥ç¼“å­˜
    if (enableCache && this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey)!;
      if (Date.now() - cached.timestamp < this.cacheDuration) {
        return { data: cached.data };
      }
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒè¯·æ±‚æ­£åœ¨è¿›è¡Œ
    if (this.pendingRequests.has(cacheKey)) {
      return this.pendingRequests.get(cacheKey)! as Promise<ApiResult<T>>;
    }

    // æ§åˆ¶å¹¶å‘è¯·æ±‚æ•°
    await this.acquireRequestSlot();

    const requestPromise = this.executeRequestWithRetry<T>(url, fetchOptions, retries, timeout);

    this.pendingRequests.set(cacheKey, requestPromise);

    try {
      const result = await requestPromise;

      // ç¼“å­˜æˆåŠŸå“åº”
      if (enableCache && result.data) {
        this.cache.set(cacheKey, {
          data: result.data,
          timestamp: Date.now()
        });
      }

      return result;
    } finally {
      this.pendingRequests.delete(cacheKey);
      this.releaseRequestSlot();
    }
  }

  private async acquireRequestSlot(): Promise<void> {
    while (this.activeRequests >= this.maxConcurrent) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    this.activeRequests++;
  }

  private releaseRequestSlot(): void {
    this.activeRequests--;
  }

  private async executeRequestWithRetry<T>(
    url: string,
    options: RequestInit,
    retries: number,
    timeout: number
  ): Promise<ApiResult<T>> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          throw new ApiError(response.status, `Request failed: ${response.statusText}`);
        }

        const responseData = await response.json();

        // å¤„ç†ç»Ÿä¸€å“åº”æ ¼å¼
        if (responseData && typeof responseData === 'object' && 'code' in responseData) {
          if (responseData.code === 200) {
            return { data: responseData.data as T };
          } else {
            throw new ApiError(responseData.code, responseData.message || 'Request failed');
          }
        }

        return { data: responseData as T };

      } catch (error) {
        lastError = error as Error;

        // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯ä¸”è¿˜æœ‰é‡è¯•æ¬¡æ•°ï¼Œåˆ™é‡è¯•
        if (this.isRetryableError(error) && attempt < retries) {
          const delay = Math.pow(2, attempt) * 1000; // æŒ‡æ•°é€€é¿
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }

        break;
      }
    }

    return { error: lastError || new ApiError(500, 'Unknown error') };
  }

  private isRetryableError(error: unknown): boolean {
    if (error instanceof ApiError) {
      // 5xxé”™è¯¯å¯ä»¥é‡è¯•
      return error.status >= 500 && error.status < 600;
    }
    if (error instanceof TypeError) {
      // ç½‘ç»œé”™è¯¯å¯ä»¥é‡è¯•
      return error.message.includes('fetch') || error.message.includes('network');
    }
    return false;
  }

  clearCache(): void {
    this.cache.clear();
  }
}

export const enhancedApiClient = new EnhancedApiClient();
```

---

## äºŒã€å¯æ‰©å±•æ€§åˆ†æ

### 2.1 çŠ¶æ€ç®¡ç† âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// ä½¿ç”¨useStateç®¡ç†ç®€å•çŠ¶æ€
const [songs, setSongs] = useState<Song[]>([]);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ ç¼ºå°‘å…¨å±€çŠ¶æ€ç®¡ç†
2. âŒ è·¨ç»„ä»¶çŠ¶æ€å…±äº«å›°éš¾
3. âŒ ç¼ºå°‘çŠ¶æ€æŒä¹…åŒ–
4. âŒ ç¼ºå°‘çŠ¶æ€æ—¶é—´æ—…è¡Œè°ƒè¯•

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 2.1.1 å¼•å…¥Zustandï¼ˆè½»é‡çº§çŠ¶æ€ç®¡ç†ï¼‰
```typescript
// infrastructure/store/useSongStore.ts
import { create } from 'zustand';
import { Song, FilterState } from '../domain/types';

interface SongStore {
  // çŠ¶æ€
  songs: Song[];
  loading: boolean;
  error: string | null;
  filters: FilterState;
  currentPage: number;
  totalPages: number;

  // æ“ä½œ
  setSongs: (songs: Song[]) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  setFilters: (filters: FilterState) => void;
  setCurrentPage: (page: number) => void;
  clearFilters: () => void;
  reset: () => void;
}

const initialState = {
  songs: [],
  loading: false,
  error: null,
  filters: {
    genres: [],
    tags: [],
    languages: []
  },
  currentPage: 1,
  totalPages: 1
};

export const useSongStore = create<SongStore>((set) => ({
  ...initialState,

  setSongs: (songs) => set({ songs }),
  setLoading: (loading) => set({ loading }),
  setError: (error) => set({ error }),
  setFilters: (filters) => set({ filters }),
  setCurrentPage: (page) => set({ currentPage: page }),
  
  clearFilters: () => set({
    filters: initialState.filters,
    currentPage: 1
  }),

  reset: () => set(initialState)
}));
```

#### 2.1.2 æŒä¹…åŒ–ä¸­é—´ä»¶
```typescript
// infrastructure/store/middleware/persist.ts
import { StateCreator } from 'zustand';

export const persistMiddleware = <T extends object>(
  config: StateCreator<T>,
  name: string
): StateCreator<T> => {
  return (set, get, api) => {
    const initialState = config(set, get, api);

    // ä»localStorageæ¢å¤çŠ¶æ€
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem(name);
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          set(parsed);
        } catch (error) {
          console.error('Failed to restore state:', error);
        }
      }
    }

    // è®¢é˜…çŠ¶æ€å˜åŒ–å¹¶ä¿å­˜
    api.subscribe((state) => {
      if (typeof window !== 'undefined') {
        localStorage.setItem(name, JSON.stringify(state));
      }
    });

    return initialState;
  };
};

// ä½¿ç”¨
export const useSongStore = create<SongStore>()(
  persistMiddleware(
    (set) => ({
      // ... store definition
    }),
    'song-store'
  )
);
```

---

### 2.2 æ€§èƒ½ä¼˜åŒ– âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// å¤§é‡æ¸²æŸ“ï¼Œç¼ºå°‘ä¼˜åŒ–
{calendarCells.map((cell, idx) => (
  <div key={idx} onClick={() => cell.live && handleSelectLive(cell.live)}>
    {/* å¤æ‚çš„æ¸²æŸ“é€»è¾‘ */}
  </div>
))}
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ ç¼ºå°‘React.memoä½¿ç”¨
2. âŒ ç¼ºå°‘useMemoå’ŒuseCallbackä¼˜åŒ–
3. âŒ ç¼ºå°‘è™šæ‹Ÿæ»šåŠ¨ï¼ˆé•¿åˆ—è¡¨ï¼‰
4. âŒ ç¼ºå°‘å›¾ç‰‡æ‡’åŠ è½½ä¼˜åŒ–
5. âŒ ç¼ºå°‘ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 2.2.1 ç»„ä»¶æ€§èƒ½ä¼˜åŒ–
```typescript
// presentation/components/features/SongTable.tsx
import { memo, useMemo, useCallback } from 'react';

interface SongRowProps {
  song: Song;
  onClick: (song: Song) => void;
}

const SongRow = memo(({ song, onClick }: SongRowProps) => {
  const handleClick = useCallback(() => {
    onClick(song);
  }, [song, onClick]);

  return (
    <div onClick={handleClick}>
      {/* æ­Œæ›²è¡Œ */}
    </div>
  );
});

SongRow.displayName = 'SongRow';

const SongTable: React.FC = () => {
  const { songs } = useSongStore();

  const sortedSongs = useMemo(() => {
    return [...songs].sort((a, b) => 
      b.performanceCount - a.performanceCount
    );
  }, [songs]);

  const handleSongClick = useCallback((song: Song) => {
    // å¤„ç†ç‚¹å‡»
  }, []);

  return (
    <div>
      {sortedSongs.map(song => (
        <SongRow 
          key={song.id} 
          song={song} 
          onClick={handleSongClick} 
        />
      ))}
    </div>
  );
};
```

#### 2.2.2 è™šæ‹Ÿæ»šåŠ¨
```typescript
// presentation/components/features/VirtualizedList.tsx
import { useMemo, useRef, useEffect } from 'react';

interface VirtualizedListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  itemHeight: number;
  containerHeight: number;
  overscan?: number;
}

function VirtualizedList<T>({
  items,
  renderItem,
  itemHeight,
  containerHeight,
  overscan = 3
}: VirtualizedListProps<T>) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  const { visibleRange, totalHeight, offsetY } = useMemo(() => {
    const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
    const endIndex = Math.min(
      items.length - 1,
      Math.ceil((scrollTop + containerHeight) / itemHeight) + overscan
    );

    return {
      visibleRange: { start: startIndex, end: endIndex },
      totalHeight: items.length * itemHeight,
      offsetY: startIndex * itemHeight
    };
  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);

  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  }, []);

  return (
    <div
      ref={containerRef}
      onScroll={handleScroll}
      style={{ height: containerHeight, overflow: 'auto' }}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {items.slice(visibleRange.start, visibleRange.end + 1).map((item, index) => (
            <div key={visibleRange.start + index} style={{ height: itemHeight }}>
              {renderItem(item, visibleRange.start + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

#### 2.2.3 ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
```typescript
// App.tsx
import { lazy, Suspense } from 'react';

const SongsPage = lazy(() => import('./presentation/pages/SongsPage'));
const GalleryPage = lazy(() => import('./presentation/pages/GalleryPage'));
const LivestreamPage = lazy(() => import('./presentation/pages/LivestreamPage'));

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <Suspense fallback={<Loading />}>
        <Routes>
          <Route path="/songs" element={<SongsPage />} />
          <Route path="/gallery" element={<GalleryPage />} />
          <Route path="/live" element={<LivestreamPage />} />
        </Routes>
      </Suspense>
    </ErrorBoundary>
  );
};
```

---

### 2.3 é…ç½®ç®¡ç† âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// infrastructure/config/config.ts
export const config = {
  api: {
    baseURL: import.meta.env.VITE_API_BASE_URL || '/api'
  },
  // å…¶ä»–é…ç½®...
};
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ é…ç½®åˆ†æ•£åœ¨å¤šä¸ªæ–‡ä»¶
2. âŒ ç¼ºå°‘ç¯å¢ƒå˜é‡éªŒè¯
3. âŒ ç¼ºå°‘é…ç½®ç±»å‹å®šä¹‰
4. âŒ ç¼ºå°‘é…ç½®çƒ­æ›´æ–°

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 2.3.1 ç»Ÿä¸€é…ç½®ç®¡ç†
```typescript
// infrastructure/config/index.ts
interface AppConfig {
  api: {
    baseURL: string;
    timeout: number;
    retries: number;
  };
  app: {
    name: string;
    version: string;
    env: 'development' | 'staging' | 'production';
  };
  features: {
    enableAnalytics: boolean;
    enableMonitoring: boolean;
    enableDevTools: boolean;
  };
  performance: {
    enableVirtualScroll: boolean;
    enableImageLazy: boolean;
    maxCacheSize: number;
  };
}

class ConfigManager {
  private config: AppConfig;
  private listeners: Set<(config: AppConfig) => void> = new Set();

  constructor() {
    this.config = this.loadConfig();
    this.validateConfig();
  }

  private loadConfig(): AppConfig {
    return {
      api: {
        baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
        timeout: parseInt(import.meta.env.VITE_API_TIMEOUT || '10000'),
        retries: parseInt(import.meta.env.VITE_API_RETRIES || '2')
      },
      app: {
        name: import.meta.env.VITE_APP_NAME || 'XXM Fans Home',
        version: import.meta.env.VITE_APP_VERSION || '1.0.0',
        env: (import.meta.env.VITE_APP_ENV as any) || 'production'
      },
      features: {
        enableAnalytics: import.meta.env.VITE_ENABLE_ANALYTICS === 'true',
        enableMonitoring: import.meta.env.VITE_ENABLE_MONITORING === 'true',
        enableDevTools: import.meta.env.VITE_ENABLE_DEV_TOOLS === 'true'
      },
      performance: {
        enableVirtualScroll: import.meta.env.VITE_ENABLE_VIRTUAL_SCROLL !== 'false',
        enableImageLazy: import.meta.env.VITE_ENABLE_IMAGE_LAZY !== 'false',
        maxCacheSize: parseInt(import.meta.env.VITE_MAX_CACHE_SIZE || '100')
      }
    };
  }

  private validateConfig(): void {
    if (!this.config.api.baseURL) {
      throw new Error('VITE_API_BASE_URL is required');
    }

    if (this.config.api.timeout <= 0) {
      throw new Error('VITE_API_TIMEOUT must be positive');
    }
  }

  get<K extends keyof AppConfig>(key: K): AppConfig[K] {
    return this.config[key];
  }

  getAll(): AppConfig {
    return { ...this.config };
  }

  subscribe(listener: (config: AppConfig) => void): () => void {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  update(partialConfig: Partial<AppConfig>): void {
    this.config = { ...this.config, ...partialConfig };
    this.listeners.forEach(listener => listener(this.config));
  }
}

export const configManager = new ConfigManager();

// ä¾¿æ·è®¿é—®
export const config = configManager.getAll();
```

---

## ä¸‰ã€å¯è¯»æ€§åˆ†æ

### 3.1 ä»£ç å¤æ‚åº¦ âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// LivestreamPage.tsx - 700+ è¡Œ
const LivestreamPage: React.FC = () => {
  // å¤§é‡çŠ¶æ€å’Œé€»è¾‘
  const [currentDate, setCurrentDate] = useState(...);
  const [showYearSelector, setShowYearSelector] = useState(...);
  const [lives, setLives] = useState(...);
  const [selectedLive, setSelectedLive] = useState(...);
  // ... æ›´å¤šçŠ¶æ€

  // å¤æ‚çš„æ¸²æŸ“é€»è¾‘
  return (
    <>
      {/* å¤§é‡åµŒå¥—çš„JSX */}
      <div className="...">
        <div className="...">
          <div className="...">
            {/* æ·±å±‚åµŒå¥— */}
          </div>
        </div>
      </div>
    </>
  );
};
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ å•ä¸ªç»„ä»¶æ–‡ä»¶è¿‡é•¿ï¼ˆ700+è¡Œï¼‰
2. âŒ æ·±å±‚åµŒå¥—çš„JSX
3. âŒ å¤æ‚çš„æ¡ä»¶æ¸²æŸ“é€»è¾‘
4. âŒ ç¼ºå°‘ç»„ä»¶æ‹†åˆ†

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 3.1.1 ç»„ä»¶æ‹†åˆ†
```typescript
// presentation/pages/LivestreamPage.tsx
const LivestreamPage: React.FC = () => {
  return (
    <>
      <LivestreamHeader />
      <LivestreamCalendar />
      <LivestreamDetails />
    </>
  );
};

// presentation/components/livestream/LivestreamHeader.tsx
const LivestreamHeader: React.FC = () => {
  return (
    <div className="...">
      <Title />
      <Controls />
    </div>
  );
};

// presentation/components/livestream/LivestreamCalendar.tsx
const LivestreamCalendar: React.FC = () => {
  return (
    <div className="...">
      <CalendarHeader />
      <CalendarGrid />
      <MonthSelector />
    </div>
  );
};

// presentation/components/livestream/LivestreamDetails.tsx
const LivestreamDetails: React.FC = () => {
  return (
    <div className="...">
      <LiveInfo />
      <VideoPlayer />
      <SongCuts />
      <Screenshots />
      <DanmakuCloud />
    </div>
  );
};
```

#### 3.1.2 è‡ªå®šä¹‰HooksæŠ½å–é€»è¾‘
```typescript
// presentation/hooks/useLivestream.ts
export const useLivestream = () => {
  const [currentDate, setCurrentDate] = useState(() => {
    const today = new Date();
    return new Date(today.getFullYear(), today.getMonth(), 1);
  });

  const [lives, setLives] = useState<Livestream[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadLives = useCallback(async (year: number, month: number) => {
    setLoading(true);
    setError(null);

    try {
      const result = await songService.getLivestreams(year, month);
      if (result.error) {
        setError(result.error.message);
        setLives([]);
      } else {
        setLives(result.data || []);
      }
    } catch (err) {
      setError('åŠ è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
      setLives([]);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadLives(currentDate.getFullYear(), currentDate.getMonth() + 1);
  }, [currentDate, loadLives]);

  const changeMonth = useCallback((offset: number) => {
    setCurrentDate(prev => new Date(
      prev.getFullYear(),
      prev.getMonth() + offset,
      1
    ));
  }, []);

  return {
    currentDate,
    lives,
    loading,
    error,
    changeMonth,
    loadLives
  };
};

// presentation/hooks/useLivestreamDetail.ts
export const useLivestreamDetail = (date: string) => {
  const [live, setLive] = useState<Livestream | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadDetail = useCallback(async () => {
    if (!date) return;

    setLoading(true);
    setError(null);

    try {
      const result = await songService.getLivestreamByDate(date);
      if (result.error) {
        setError(result.error.message);
        setLive(null);
      } else {
        setLive(result.data || null);
      }
    } catch (err) {
      setError('åŠ è½½è¯¦æƒ…å¤±è´¥');
      setLive(null);
    } finally {
      setLoading(false);
    }
  }, [date]);

  useEffect(() => {
    loadDetail();
  }, [loadDetail]);

  return { live, loading, error, reload: loadDetail };
};
```

---

### 3.2 å‘½åè§„èŒƒ âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// æ··åˆçš„å‘½åé£æ ¼
const currentDate = ...          // camelCase âœ“
const minYear = ...               // camelCase âœ“
const LivestreamPage = ...       // PascalCase âœ“
const songService = ...          // camelCase âœ“
const handleSelectLive = ...     // camelCase âœ“

// ä½†æœ‰äº›åœ°æ–¹ä¸ä¸€è‡´
const setTempYear = ...          // OK
const setActiveScreenshot = ...  // OK
const handlePrevScreenshot = ... // OK
```

**é—®é¢˜åˆ†æï¼š**
1. âš ï¸ æ•´ä½“å‘½åè§„èŒƒè¾ƒå¥½ï¼Œä½†éœ€è¦ç»Ÿä¸€æ–‡æ¡£åŒ–
2. âš ï¸ ç¼ºå°‘å‘½åçº¦å®šæ–‡æ¡£
3. âš ï¸ ç¼ºå°‘ESLintè§„åˆ™å¼ºåˆ¶æ‰§è¡Œ

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 3.2.1 å‘½åçº¦å®šæ–‡æ¡£
```markdown
# å‘½åçº¦å®š

## ç»„ä»¶
- ä½¿ç”¨ PascalCase
- ç¤ºä¾‹: `SongTable`, `LivestreamPage`, `ErrorBoundary`

## å‡½æ•°/æ–¹æ³•
- ä½¿ç”¨ camelCase
- äº‹ä»¶å¤„ç†å™¨ä»¥ `handle` å¼€å¤´
- ç¤ºä¾‹: `loadSongs`, `handleSongClick`, `fetchData`

## å˜é‡
- ä½¿ç”¨ camelCase
- å¸ƒå°”å€¼ä»¥ `is/has/should` å¼€å¤´
- ç¤ºä¾‹: `isLoading`, `hasError`, `shouldRender`

## å¸¸é‡
- ä½¿ç”¨ UPPER_SNAKE_CASE
- ç¤ºä¾‹: `API_BASE_URL`, `MAX_RETRIES`

## ç±»å‹/æ¥å£
- ä½¿ç”¨ PascalCase
- æ¥å£ä»¥ `I` å¼€å¤´ï¼ˆå¯é€‰ï¼‰
- ç¤ºä¾‹: `Song`, `ISongService`, `ApiResponse`

## æ–‡ä»¶
- ç»„ä»¶æ–‡ä»¶: PascalCase
- å·¥å…·æ–‡ä»¶: camelCase
- æµ‹è¯•æ–‡ä»¶: *.test.ts/*.test.tsx
- ç¤ºä¾‹: `SongTable.tsx`, `utils.ts`, `SongTable.test.tsx`
```

#### 3.2.2 ESLinté…ç½®
```javascript
// .eslintrc.cjs
module.exports = {
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended'
  ],
  rules: {
    // å‘½åè§„èŒƒ
    '@typescript-eslint/naming-convention': [
      'error',
      {
        selector: 'interface',
        format: ['PascalCase'],
        custom: {
          regex: '^I[A-Z]',
          match: true
        }
      },
      {
        selector: 'typeAlias',
        format: ['PascalCase']
      },
      {
        selector: 'variable',
        format: ['camelCase', 'UPPER_CASE'],
        filter: {
          regex: '^(is|has|should)[A-Z]',
          match: true
        }
      },
      {
        selector: 'function',
        format: ['camelCase'],
        filter: {
          regex: '^(handle|on)[A-Z]',
          match: true
        }
      }
    ],
    // Reactè§„åˆ™
    'react/react-in-jsx-scope': 'off',
    'react/prop-types': 'off',
    // React Hooksè§„åˆ™
    'react-hooks/rules-of-hooks': 'error',
    'react-hooks/exhaustive-deps': 'warn'
  }
};
```

---

### 3.3 ä»£ç æ³¨é‡Šå’Œæ–‡æ¡£ âš ï¸

**å½“å‰çŠ¶æ€ï¼š**
```typescript
// ç¼ºå°‘æˆ–ä¸è¶³çš„æ³¨é‡Š
const [showYearSelector, setShowYearSelector] = useState(false);

// åªæœ‰ç®€å•æ³¨é‡Š
// è·å–ç›´æ’­é…ç½®
useEffect(() => {
  // ...
}, []);
```

**é—®é¢˜åˆ†æï¼š**
1. âŒ ç¼ºå°‘å¤æ‚é€»è¾‘çš„æ³¨é‡Š
2. âŒ ç¼ºå°‘å‡½æ•°/æ–¹æ³•çš„JSDoc
3. âŒ ç¼ºå°‘ç»„ä»¶çš„ä½¿ç”¨ç¤ºä¾‹
4. âŒ ç¼ºå°‘æ¶æ„è®¾è®¡æ–‡æ¡£

**ä¼˜åŒ–æ–¹æ¡ˆï¼š**

#### 3.3.1 JSDocæ³¨é‡Š
```typescript
/**
 * ç›´æ’­é¡µé¢ç»„ä»¶
 * 
 * æ˜¾ç¤ºæœˆåº¦ç›´æ’­æ—¥å†ï¼Œæ”¯æŒæŒ‰å¹´æœˆæµè§ˆç›´æ’­è®°å½•ã€‚
 * ç‚¹å‡»æ—¥æœŸå¯æŸ¥çœ‹è¯¥æ—¥æœŸçš„ç›´æ’­è¯¦æƒ…ï¼ŒåŒ…æ‹¬è§†é¢‘å›æ”¾ã€æ­Œåˆ‡åˆ—è¡¨ã€æˆªå›¾ç­‰ã€‚
 * 
 * @component
 * @example
 * ```tsx
 * <LivestreamPage />
 * ```
 * 
 * @returns {JSX.Element} ç›´æ’­é¡µé¢
 */
const LivestreamPage: React.FC = () => {
  // ...
};

/**
 * è·å–æœˆåº¦ç›´æ’­åˆ—è¡¨
 * 
 * @param {number} year - å¹´ä»½
 * @param {number} month - æœˆä»½ï¼ˆ1-12ï¼‰
 * @returns {Promise<void>}
 * 
 * @example
 * ```typescript
 * await loadLives(2024, 1); // åŠ è½½2024å¹´1æœˆçš„ç›´æ’­
 * ```
 */
const loadLives = async (year: number, month: number): Promise<void> => {
  // ...
};

/**
 * è®¡ç®—æ—¥å†å•å…ƒæ ¼
 * 
 * æ ¹æ®å½“å‰å¹´æœˆç”Ÿæˆæ—¥å†ç½‘æ ¼ï¼ŒåŒ…æ‹¬ï¼š
 * - ç©ºç™½å•å…ƒæ ¼ï¼ˆæœˆåˆå‰çš„ç©ºç™½ï¼‰
 * - æ—¥æœŸå•å…ƒæ ¼ï¼ˆåŒ…å«æ—¥æœŸå’Œç›´æ’­æ ‡è®°ï¼‰
 * 
 * @returns {CalendarCell[]} æ—¥å†å•å…ƒæ ¼æ•°ç»„
 */
const calendarCells = useMemo(() => {
  // ...
}, [daysInMonth, lives, currentDate]);
```

#### 3.3.2 ç»„ä»¶æ–‡æ¡£æ¨¡æ¿
```typescript
/**
 * SongTable - æ­Œæ›²è¡¨æ ¼ç»„ä»¶
 * 
 * æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨ï¼Œæ”¯æŒæœç´¢ã€ç­›é€‰ã€æ’åºå’Œåˆ†é¡µåŠŸèƒ½ã€‚
 * 
 * @feature æœç´¢åŠŸèƒ½ - æ”¯æŒæŒ‰æ­Œåã€æ­Œæ‰‹æœç´¢
 * @feature ç­›é€‰åŠŸèƒ½ - æ”¯æŒæŒ‰æ›²é£ã€æ ‡ç­¾ã€è¯­ç§ç­›é€‰
 * @feature æ’åºåŠŸèƒ½ - æ”¯æŒæŒ‰æ¼”å”±æ¬¡æ•°ã€æœ€è¿‘æ¼”å”±æ’åº
 * @feature åˆ†é¡µåŠŸèƒ½ - æ”¯æŒåˆ†é¡µåŠ è½½ï¼Œæ¯é¡µ50æ¡
 * 
 * @example
 * ```tsx
 * <SongTable />
 * ```
 * 
 * @example è‡ªå®šä¹‰ç­›é€‰
 * ```tsx
 * <SongTable 
 *   initialFilters={{ genres: ['æµè¡Œ'], languages: ['ä¸­æ–‡'] }}
 *   onFilterChange={(filters) => console.log(filters)}
 * />
 * ```
 * 
 * @example é›†æˆåˆ°çŠ¶æ€ç®¡ç†
 * ```tsx
 * function SongsPage() {
 *   const { songs, filters } = useSongStore();
 *   return <SongTable data={songs} filters={filters} />;
 * }
 * ```
 * 
 * @author XXM Team
 * @version 1.0.0
 * @since 2024-01-01
 */
```

---

## å››ã€ç»¼åˆä¼˜åŒ–æ–¹æ¡ˆ

### 4.1 å®æ–½ä¼˜å…ˆçº§

| ä¼˜å…ˆçº§ | ä¼˜åŒ–é¡¹ | é¢„è®¡å·¥ä½œé‡ | å½±å“èŒƒå›´ |
|--------|--------|------------|----------|
| ğŸ”´ P0 | å¼•å…¥å•å…ƒæµ‹è¯• | 3-5å¤© | æ•´ä½“è´¨é‡ |
| ğŸ”´ P0 | ç»Ÿä¸€é”™è¯¯å¤„ç† | 2-3å¤© | ç”¨æˆ·ä½“éªŒ |
| ğŸ”´ P0 | æ—¥å¿—ç³»ç»Ÿ | 2-3å¤© | é—®é¢˜æ’æŸ¥ |
| ğŸŸ¡ P1 | çŠ¶æ€ç®¡ç† | 2-3å¤© | æ¶æ„ä¼˜åŒ– |
| ğŸŸ¡ P1 | æ€§èƒ½ä¼˜åŒ– | 3-5å¤© | ç”¨æˆ·ä½“éªŒ |
| ğŸŸ¡ P1 | APIè¯·æ±‚å¢å¼º | 2-3å¤© | å¯é æ€§ |
| ğŸŸ¢ P2 | ç»„ä»¶æ‹†åˆ† | 5-7å¤© | å¯ç»´æŠ¤æ€§ |
| ğŸŸ¢ P2 | æ–‡æ¡£å®Œå–„ | æŒç»­è¿›è¡Œ | å›¢é˜Ÿåä½œ |

### 4.2 æŠ€æœ¯æ ˆå‡çº§å»ºè®®

#### 4.2.1 æ–°å¢ä¾èµ–
```json
{
  "dependencies": {
    "zustand": "^4.0.0",           // çŠ¶æ€ç®¡ç†
    "react-query": "^3.39.0",       // æ•°æ®è·å–å’Œç¼“å­˜
    "@tanstack/react-query": "^5.0.0"
  },
  "devDependencies": {
    "vitest": "^2.0.0",             // æµ‹è¯•æ¡†æ¶
    "@vitest/ui": "^2.0.0",         // æµ‹è¯•UI
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.0.0",
    "@testing-library/user-event": "^14.0.0",
    "eslint": "^8.0.0",             // ä»£ç è§„èŒƒ
    "prettier": "^3.0.0",           // ä»£ç æ ¼å¼åŒ–
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0"
  }
}
```

#### 4.2.2 é…ç½®æ–‡ä»¶
```
repo/xxm_fans_frontend/
â”œâ”€â”€ .eslintrc.cjs
â”œâ”€â”€ .prettierrc
â”œâ”€â”€ vitest.config.ts
â”œâ”€â”€ tsconfig.json                  # å¢å¼ºé…ç½®
â””â”€â”€ vitest.setup.ts                # æµ‹è¯•é…ç½®
```

### 4.3 å®æ–½è·¯çº¿å›¾

#### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€è®¾æ–½ï¼ˆç¬¬1-2å‘¨ï¼‰
- [ ] æ­å»ºæµ‹è¯•æ¡†æ¶ï¼ˆVitestï¼‰
- [ ] é…ç½®ESLintå’ŒPrettier
- [ ] å®ç°ç»Ÿä¸€é”™è¯¯å¤„ç†
- [ ] å®ç°æ—¥å¿—ç³»ç»Ÿ
- [ ] ç¼–å†™æµ‹è¯•è§„èŒƒæ–‡æ¡£

#### ç¬¬äºŒé˜¶æ®µï¼šæ ¸å¿ƒä¼˜åŒ–ï¼ˆç¬¬3-4å‘¨ï¼‰
- [ ] å¼•å…¥çŠ¶æ€ç®¡ç†ï¼ˆZustandï¼‰
- [ ] å¢å¼ºAPIå®¢æˆ·ç«¯
- [ ] å®ç°è¯·æ±‚é‡è¯•å’Œç¼“å­˜
- [ ] ç¼–å†™æ ¸å¿ƒæ¨¡å—æµ‹è¯•

#### ç¬¬ä¸‰é˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆç¬¬5-6å‘¨ï¼‰
- [ ] ç»„ä»¶æ€§èƒ½ä¼˜åŒ–ï¼ˆReact.memoï¼‰
- [ ] å®ç°è™šæ‹Ÿæ»šåŠ¨
- [ ] ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
- [ ] å›¾ç‰‡æ‡’åŠ è½½ä¼˜åŒ–

#### ç¬¬å››é˜¶æ®µï¼šä»£ç é‡æ„ï¼ˆç¬¬7-8å‘¨ï¼‰
- [ ] æ‹†åˆ†å¤§å‹ç»„ä»¶
- [ ] æŠ½å–è‡ªå®šä¹‰Hooks
- [ ] å®Œå–„ä»£ç æ³¨é‡Š
- [ ] ç¼–å†™ç»„ä»¶æ–‡æ¡£

### 4.4 è´¨é‡æŒ‡æ ‡

#### 4.4.1 æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡
```
è¯­å¥è¦†ç›–ç‡: â‰¥ 80%
åˆ†æ”¯è¦†ç›–ç‡: â‰¥ 75%
å‡½æ•°è¦†ç›–ç‡: â‰¥ 80%
è¡Œè¦†ç›–ç‡: â‰¥ 80%
```

#### 4.4.2 æ€§èƒ½æŒ‡æ ‡
```
é¦–å±åŠ è½½æ—¶é—´: < 2s
äº¤äº’å“åº”æ—¶é—´: < 100ms
Bundleå¤§å°: < 500KB (gzip)
Lighthouseè¯„åˆ†: â‰¥ 90
```

#### 4.4.3 ä»£ç è´¨é‡æŒ‡æ ‡
```
TypeScriptè¦†ç›–ç‡: 100%
ESLintè­¦å‘Š: 0
å¤æ‚åº¦: < 15 (æ¯ä¸ªå‡½æ•°)
ç»„ä»¶è¡Œæ•°: < 300 (æ¯ä¸ªç»„ä»¶)
```

---

## äº”ã€æ€»ç»“

XXM Fans Home å‰ç«¯é¡¹ç›®å…·æœ‰è‰¯å¥½çš„DDDæ¶æ„åŸºç¡€ï¼Œä½†åœ¨å¥å£®æ€§ã€å¯æ‰©å±•æ€§å’Œå¯è¯»æ€§æ–¹é¢ä»æœ‰è¾ƒå¤§æå‡ç©ºé—´ã€‚é€šè¿‡ç³»ç»Ÿæ€§çš„ä¼˜åŒ–ï¼Œå¯ä»¥æ˜¾è‘—æå‡é¡¹ç›®è´¨é‡å’Œå¼€å‘æ•ˆç‡ã€‚

### æ ¸å¿ƒæ”¹è¿›ç‚¹

1. **å¥å£®æ€§**: å»ºç«‹å®Œå–„çš„æµ‹è¯•ä½“ç³»ã€ç»Ÿä¸€é”™è¯¯å¤„ç†ã€ç»“æ„åŒ–æ—¥å¿—
2. **å¯æ‰©å±•æ€§**: å¼•å…¥çŠ¶æ€ç®¡ç†ã€æ€§èƒ½ä¼˜åŒ–ã€å¢å¼ºAPIå®¢æˆ·ç«¯
3. **å¯è¯»æ€§**: ç»„ä»¶æ‹†åˆ†ã€ä»£ç æ³¨é‡Šã€å‘½åè§„èŒƒ

### é¢„æœŸæ”¶ç›Š

- **å¼€å‘æ•ˆç‡**: æå‡30-40%
- **Bugç‡**: é™ä½50-70%
- **æ€§èƒ½**: æå‡20-30%
- **ç»´æŠ¤æˆæœ¬**: é™ä½40-50%

### ä¸‹ä¸€æ­¥è¡ŒåŠ¨

å»ºè®®æŒ‰ç…§å®æ–½è·¯çº¿å›¾åˆ†é˜¶æ®µæ¨è¿›ï¼Œä¼˜å…ˆå®ŒæˆP0çº§åˆ«çš„ä¼˜åŒ–é¡¹ï¼Œç¡®ä¿é¡¹ç›®è´¨é‡ç¨³æ­¥æå‡ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0.0
**ç¼–å†™æ—¥æœŸ**: 2026-01-31
**ç¼–å†™äºº**: XXM Team
**å®¡æ ¸äºº**: å¾…å®š