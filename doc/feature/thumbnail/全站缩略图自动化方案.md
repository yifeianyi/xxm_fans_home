# 全站缩略图自动化方案

## 一、背景与目标

### 1.1 当前状况
项目中有多个图片资源目录：
- **gallery/** - 图集图片（约 647MB，310 个文件）
- **covers/** - 歌曲封面图片
- **footprint/** - 粉丝二创作品图片
- **settings/** - 网站设置图片（favicon、艺人头像等）
- **songlist/** - 模板歌单图片

当前只有 gallery 模块实现了基础的缩略图功能，且：
- 上传图片时不会自动生成缩略图
- 删除图片时不会自动删除对应缩略图
- 其他模块完全没有缩略图支持

### 1.2 优化目标
1. **全站统一缩略图**：所有图片模块都支持缩略图
2. **自动化生成**：上传图片时自动生成缩略图
3. **自动化清理**：删除图片时自动删除对应缩略图
4. **按需使用**：
   - 列表展示、缩略图预览：使用缩略图
   - 网站设置图片：使用原图（favicon、艺人头像等）
   - 图集放大查看：使用原图
5. **性能优化**：减少带宽消耗，提升加载速度

---

## 二、技术方案

### 2.1 整体架构

采用 **Django 信号 + 统一缩略图生成器** 方案：

```
图片上传操作
    ↓
Django 信号（post_save）
    ↓
ThumbnailGenerator.generate_thumbnail()
    ↓
自动生成缩略图并保存

图片删除操作
    ↓
Django 信号（pre_delete）
    ↓
ThumbnailGenerator.delete_thumbnail()
    ↓
自动删除对应缩略图
```

### 2.2 缩略图规范

#### 2.2.1 缩略图尺寸
根据不同用途设置不同尺寸：

| 模块 | 用途 | 尺寸 | 备注 |
|------|------|------|------|
| gallery | 列表展示 | 400x400 | 最大边 400px |
| gallery | 网格展示 | 300x300 | 最大边 300px |
| covers | 列表展示 | 300x300 | 保持宽高比 |
| footprint | 封面展示 | 300x300 | 保持宽高比，只显示缩略图 |
| songlist | 列表展示 | 不压缩 | 直接使用原图 |

#### 2.2.2 缩略图存储
- **存储位置**：`media/thumbnails/{module}/`
- **命名规则**：保持原图文件名，只改变扩展名
  - 原图：`gallery/album1/photo1.jpg`
  - 缩略图：`thumbnails/gallery/album1/photo1.webp`
  - 示例：`photo1.webp`（与原图同名，仅扩展名不同）

#### 2.2.3 支持格式
- **输入**：JPG、PNG、GIF、WEBP
- **输出**：统一使用 WEBP 格式（更小体积，更好的压缩率）
- **GIF 处理**：提取第一帧作为缩略图
- **质量设置**：JPEG/WEBP 质量 85

### 2.3 使用规则

| 模块 | 场景 | 使用 | 原因 |
|------|------|------|------|
| gallery | 列表展示 | 缩略图 | 减少带宽 |
| gallery | 图片详情/放大 | 原图 | 保证质量 |
| covers | 列表展示 | 缩略图 | 减少带宽 |
| covers | 详情查看 | 原图 | 保证质量 |
| footprint | 封面展示 | 缩略图 | 只显示缩略图，不提供原图查看 |
| footprint | 详情查看 | 不提供 | 只用于封面展示 |
| settings | favicon | 原图 | 小图标，无需缩略图 |
| settings | 艺人头像 | 原图 | 头像需要高质量 |
| songlist | 所有场景 | 原图 | 不需要压缩，直接使用原图 |

### 2.4 B 站封面下载
- 从 B 站下载的封面图片自动生成缩略图
- 下载完成后自动调用缩略图生成器
- 缩略图用于列表展示，原图保留用于详情查看

### 2.5 封面 URL 处理策略

采用 **数据库保持原图，API 同时返回两个 URL** 的策略：

#### 2.5.1 数据库存储
- 所有封面字段（`cover_url`、`photo_url` 等）保持存储原图路径
- 不修改现有数据库结构，保持向后兼容

#### 2.5.2 API 返回格式
每个有封面的模型同时返回两个 URL：

```json
{
  "cover_url": "/media/covers/2025/01/2025-01-15.jpg",           // 原图（详情查看）
  "cover_thumbnail_url": "/media/thumbnails/covers/2025/01/2025-01-15.webp"  // 缩略图（封面展示）
}
```

#### 2.5.3 使用场景

| 场景 | 使用 URL | 说明 |
|------|---------|------|
| 封面列表展示 | `cover_thumbnail_url` | 节省带宽，提升加载速度 |
| 图集封面卡片 | `cover_thumbnail_url` | 节省带宽，提升加载速度 |
| 图集详情页 | `cover_url` | 保证高质量展示 |
| 图片放大查看 | `cover_url` 或 `url` | 保证高质量查看 |

#### 2.5.4 实现方式

**后端模型方法**：
```python
class Gallery(models.Model):
    cover_url = models.CharField(...)  # 存储原图路径
    
    def get_cover_thumbnail_url(self):
        """获取封面缩略图 URL"""
        if not self.cover_url:
            return None
        from core.thumbnail_generator import ThumbnailGenerator
        return ThumbnailGenerator.get_thumbnail_url(self.cover_url)
```

**API 视图**：
```python
def gallery_detail(request, gallery_id):
    gallery = Gallery.objects.get(id=gallery_id)
    return success_response({
        'cover_url': gallery.cover_url,
        'cover_thumbnail_url': gallery.get_cover_thumbnail_url(),
        # ... 其他字段
    })
```

#### 2.5.5 优势
- ✅ 保持数据库字段不变，无需迁移
- ✅ 保留原图路径，便于高质量查看
- ✅ API 同时提供两个 URL，前端灵活选择
- ✅ 向后兼容，不影响现有功能

---

## 三、实现步骤

### 3.1 创建通用缩略图生成器

**文件路径**：`repo/xxm_fans_backend/core/thumbnail_generator.py`

```python
import os
from pathlib import Path
from PIL import Image
from django.core.files.storage import default_storage
from django.conf import settings


class ThumbnailGenerator:
    """通用缩略图生成器 - 支持全站缩略图"""

    # 默认缩略图尺寸配置
    THUMBNAIL_SIZES = {
        'gallery': (400, 400),
        'covers': (300, 300),
        'footprint': (300, 300),
    }

    # 质量设置
    QUALITY = 85

    @classmethod
    def get_module_from_path(cls, file_path: str) -> str:
        """从文件路径提取模块名称"""
        file_path = file_path.lstrip('/')
        
        # 映射路径到模块
        if file_path.startswith('gallery/'):
            return 'gallery'
        elif file_path.startswith('covers/'):
            return 'covers'
        elif file_path.startswith('footprint/'):
            return 'footprint'
        elif file_path.startswith('songlist/'):
            return 'songlist'
        else:
            return 'default'

    @classmethod
    def get_thumbnail_size(cls, module: str) -> tuple:
        """获取指定模块的缩略图尺寸"""
        return cls.THUMBNAIL_SIZES.get(module, (300, 300))

    @classmethod
    def get_thumbnail_path(cls, original_path: str) -> str:
        """获取缩略图存储路径 - 保持原图文件名和目录结构"""
        original_path = original_path.lstrip('/')
        
        # 获取模块名称
        module = cls.get_module_from_path(original_path)
        
        # 解析原文件扩展名
        ext = Path(original_path).suffix.lower()
        
        # 统一使用 webp 格式（除了 GIF）
        if ext == '.gif':
            output_ext = '.gif'
        else:
            output_ext = '.webp'
        
        # 构建缩略图路径：thumbnails/{module}/{original_dir}/{filename}.webp
        # 保持原图的目录结构，只改变根目录和扩展名
        if '/' in original_path:
            # 移除模块前缀，保留子目录
            parts = original_path.split('/', 1)
            relative_path = parts[1] if len(parts) > 1 else ''
        else:
            relative_path = original_path
        
        # 替换扩展名
        thumbnail_path = os.path.join('thumbnails', module, Path(relative_path).with_suffix(output_ext).as_posix())
        
        return thumbnail_path

    @classmethod
    def generate_thumbnail(cls, original_path: str, force: bool = False) -> str:
        """生成缩略图
        
        Args:
            original_path: 原文件路径
            force: 是否强制重新生成
        
        Returns:
            缩略图路径，失败时返回原图路径
        """
        original_path = original_path.lstrip('/')
        
        # 获取模块名称
        module = cls.get_module_from_path(original_path)
        
        # songlist 模块不生成缩略图
        if module == 'songlist':
            return original_path
        
        thumbnail_path = cls.get_thumbnail_path(original_path)

        # 检查缩略图是否已存在
        if not force and default_storage.exists(thumbnail_path):
            # 比较原图和缩略图的修改时间，自动检测更新
            try:
                original_full_path = os.path.join(default_storage.location, original_path)
                thumbnail_full_path = os.path.join(default_storage.location, thumbnail_path)
                
                original_mtime = os.path.getmtime(original_full_path)
                thumbnail_mtime = os.path.getmtime(thumbnail_full_path)
                
                # 如果原图比缩略图新，说明原图已更新，需要重新生成
                if original_mtime > thumbnail_mtime:
                    print(f"检测到原图已更新，重新生成缩略图: {original_path}")
                else:
                    return thumbnail_path  # 原图未更新，直接使用现有缩略图
            except Exception as e:
                print(f"比较文件修改时间失败: {e}")
                return thumbnail_path  # 出错时使用现有缩略图

        # 检查原图是否存在
        if not default_storage.exists(original_path):
            return original_path

        # 读取原图片
        try:
            with default_storage.open(original_path, 'rb') as f:
                img = Image.open(f)

                # 处理 GIF：只取第一帧
                if getattr(img, 'is_animated', False):
                    img.seek(0)
                    img = img.convert('RGB')

                # 获取缩略图尺寸
                thumbnail_size = cls.get_thumbnail_size(module)

                # 计算缩略图尺寸（保持宽高比）
                img.thumbnail(thumbnail_size, Image.Resampling.LANCZOS)

                # 创建缩略图目录
                thumb_dir = os.path.dirname(thumbnail_path)
                thumb_dir_full = os.path.join(default_storage.location, thumb_dir)
                if not os.path.exists(thumb_dir_full):
                    os.makedirs(thumb_dir_full, exist_ok=True)

                # 保存缩略图
                output_ext = Path(thumbnail_path).suffix.lower()
                thumbnail_full_path = os.path.join(default_storage.location, thumbnail_path)

                if output_ext in ['.jpg', '.jpeg']:
                    img.save(thumbnail_full_path, 'JPEG', quality=cls.QUALITY, optimize=True)
                elif output_ext == '.png':
                    img.save(thumbnail_full_path, 'PNG', optimize=True)
                elif output_ext == '.webp':
                    img.save(thumbnail_full_path, 'WEBP', quality=cls.QUALITY, method=6)
                elif output_ext == '.gif':
                    img.save(thumbnail_full_path, 'GIF')

                return thumbnail_path

        except Exception as e:
            print(f"生成缩略图失败: {original_path}, 错误: {e}")
            return original_path  # 失败时返回原图路径

    @classmethod
    def delete_thumbnail(cls, original_path: str) -> bool:
        """删除对应的缩略图
        
        Args:
            original_path: 原文件路径
        
        Returns:
            是否删除成功
        """
        original_path = original_path.lstrip('/')
        
        # 获取模块名称
        module = cls.get_module_from_path(original_path)
        
        # songlist 模块没有缩略图
        if module == 'songlist':
            return False
        
        thumbnail_path = cls.get_thumbnail_path(original_path)

        try:
            if default_storage.exists(thumbnail_path):
                default_storage.delete(thumbnail_path)
                return True
            return False
        except Exception as e:
            print(f"删除缩略图失败: {thumbnail_path}, 错误: {e}")
            return False

    @classmethod
    def get_thumbnail_url(cls, original_url: str) -> str:
        """获取缩略图 URL
        
        Args:
            original_url: 原图 URL
        
        Returns:
            缩略图 URL，失败时返回原图 URL
        """
        if not original_url:
            return original_url

        original_path = original_url.lstrip('/')
        
        # 获取模块名称
        module = cls.get_module_from_path(original_path)
        
        # settings 和 songlist 模块不使用缩略图
        if original_path.startswith('settings/') or module == 'songlist':
            return original_url
        
        # footprint 模块只返回缩略图 URL
        if module == 'footprint':
            thumbnail_path = cls.generate_thumbnail(original_path)
            if thumbnail_path != original_path:
                return f"/media/{thumbnail_path}"
            return original_url
        
        thumbnail_path = cls.generate_thumbnail(original_path)

        if thumbnail_path == original_path:
            return original_url

        # 转换为 URL
        return f"/media/{thumbnail_path}"

    @classmethod
    def batch_generate_thumbnails(cls, module: str = None):
        """批量生成缩略图
        
        Args:
            module: 指定模块，None 表示全部
        """
        modules_to_scan = [module] if module else ['gallery', 'covers', 'footprint']
        
        total_count = 0
        success_count = 0

        for scan_module in modules_to_scan:
            if not default_storage.exists(scan_module):
                print(f"跳过不存在的目录: {scan_module}")
                continue

            print(f"扫描目录: {scan_module}")

            def scan_directory(directory):
                nonlocal total_count, success_count

                try:
                    dirs, files = default_storage.listdir(directory)
                    for file in files:
                        if file.lower().endswith(('.jpg', '.jpeg', '.png', '.webp', '.gif')):
                            total_count += 1
                            file_path = f"{directory}/{file}"

                            try:
                                thumbnail_path = cls.generate_thumbnail(file_path)
                                if thumbnail_path != file_path:
                                    success_count += 1
                                    print(f'✓ {file_path}')
                            except Exception as e:
                                print(f'✗ {file_path}: {e}')

                    for subdir in dirs:
                        scan_directory(f"{directory}/{subdir}")
                except Exception as e:
                    print(f"扫描目录失败 {directory}: {e}")

            scan_directory(scan_module)

        print(f"完成！总共处理 {total_count} 个文件，成功生成 {success_count} 个缩略图")

    @classmethod
    def cleanup_orphan_thumbnails(cls):
        """清理孤立的缩略图（原图已不存在）"""
        thumbnails_dir = 'thumbnails'
        
        if not default_storage.exists(thumbnails_dir):
            print("缩略图目录不存在")
            return

        deleted_count = 0

        def scan_directory(directory):
            nonlocal deleted_count

            try:
                dirs, files = default_storage.listdir(directory)
                for file in files:
                    file_path = f"{directory}/{file}"
                    
                    # 转换缩略图路径回原图路径
                    # thumbnails/gallery/album1/photo1.webp -> gallery/album1/photo1.jpg
                    if file.endswith('.webp') or file.endswith('.gif'):
                        # 提取相对路径
                        relative_path = file_path.replace('thumbnails/', '', 1)
                        # 分割路径，提取模块和相对路径
                        parts = relative_path.split('/', 1)
                        if len(parts) < 2:
                            continue
                        
                        module = parts[0]
                        original_relative = parts[1]
                        
                        # 转换扩展名（webp -> jpg/png 等）
                        # 需要检查原图可能的扩展名
                        possible_extensions = ['.jpg', '.jpeg', '.png', '.gif']
                        original_exists = False
                        original_path = None
                        
                        for ext in possible_extensions:
                            test_path = f"{module}/{Path(original_relative).stem}{ext}"
                            if default_storage.exists(test_path):
                                original_exists = True
                                original_path = test_path
                                break
                        
                        if not original_exists:
                            default_storage.delete(file_path)
                            deleted_count += 1
                            print(f'✓ 删除孤立缩略图: {file_path}')

                for subdir in dirs:
                    scan_directory(f"{directory}/{subdir}")
            except Exception as e:
                print(f"扫描目录失败 {directory}: {e}")

        scan_directory(thumbnails_dir)
        print(f"完成！删除了 {deleted_count} 个孤立缩略图")
```

### 3.2 创建 Django 信号处理器

**文件路径**：`repo/xxm_fans_backend/core/signals.py`

```python
from django.db.models.signals import post_save, pre_delete
from django.dispatch import receiver
from django.core.files.storage import default_storage
from .thumbnail_generator import ThumbnailGenerator


@receiver(post_save)
def generate_thumbnail_on_upload(sender, instance, **kwargs):
    """图片上传或更新时自动生成/更新缩略图
    
    监听所有包含 ImageField 的模型
    - 新上传图片：自动生成缩略图
    - 更新图片：自动检测并重新生成缩略图（基于文件修改时间）
    """
    # 获取模型的所有 ImageField
    image_fields = []
    for field in instance._meta.get_fields():
        if field.__class__.__name__ == 'ImageField':
            image_fields.append(field.name)
    
    if not image_fields:
        return
    
    # 为每个图片字段生成缩略图
    for field_name in image_fields:
        field = getattr(instance, field_name)
        if field:
            # 获取文件路径
            file_path = field.name
            
            # 跳过 settings 模块的图片
            if file_path.startswith('settings/'):
                continue
            
            # 生成缩略图（会自动检测原图是否更新）
            try:
                ThumbnailGenerator.generate_thumbnail(file_path)
                print(f"✓ 自动处理缩略图: {file_path}")
            except Exception as e:
                print(f"✗ 生成缩略图失败: {file_path}, 错误: {e}")


@receiver(pre_delete)
def delete_thumbnail_on_delete(sender, instance, **kwargs):
    """图片删除时自动删除缩略图
    
    监听所有包含 ImageField 的模型
    """
    # 获取模型的所有 ImageField
    image_fields = []
    for field in instance._meta.get_fields():
        if field.__class__.__name__ == 'ImageField':
            image_fields.append(field.name)
    
    if not image_fields:
        return
    
    # 为每个图片字段删除缩略图
    for field_name in image_fields:
        field = getattr(instance, field_name)
        if field:
            # 获取文件路径
            file_path = field.name
            
            # 跳过 settings 模块的图片
            if file_path.startswith('settings/'):
                continue
            
            # 删除缩略图
            try:
                ThumbnailGenerator.delete_thumbnail(file_path)
                print(f"✓ 自动删除缩略图: {file_path}")
            except Exception as e:
                print(f"✗ 删除缩略图失败: {file_path}, 错误: {e}")
```

### 3.3 注册信号

**文件路径**：`repo/xxm_fans_backend/core/apps.py`

```python
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'
    verbose_name = '核心模块'

    def ready(self):
        """应用启动时注册信号"""
        # 导入信号处理器
        import core.signals
```

### 3.4 更新 gallery 模块

#### 3.4.1 更新 utils.py

**文件路径**：`repo/xxm_fans_backend/gallery/utils.py`

```python
# 删除原有的 ThumbnailGenerator 类
# 改为导入通用的缩略图生成器

from core.thumbnail_generator import ThumbnailGenerator as BaseThumbnailGenerator

# 为了向后兼容，创建别名
ThumbnailGenerator = BaseThumbnailGenerator
```

#### 3.4.2 更新 models.py 的 add_image 方法

**文件路径**：`repo/xxm_fans_backend/gallery/models.py`

```python
def add_image(self, image_file, filename=None):
    """添加图片到图集"""
    if not filename:
        # 自动生成文件名
        existing_images = self.get_images()
        next_num = len(existing_images) + 1
        ext = os.path.splitext(image_file.name)[1].lower()
        filename = f"{str(next_num).zfill(3)}{ext}"

    folder_path = self.folder_path.lstrip('/')

    # 确保文件夹存在
    if not default_storage.exists(folder_path):
        default_storage.makedirs(folder_path)

    # 保存图片
    save_path = os.path.join(folder_path, filename)
    default_storage.save(save_path, image_file)

    # 自动生成缩略图（通过信号处理）
    from core.thumbnail_generator import ThumbnailGenerator
    ThumbnailGenerator.generate_thumbnail(save_path)

    # 更新图片数量
    self.refresh_image_count()

    return filename
```

#### 3.4.3 更新 models.py 的 delete_image 方法

**文件路径**：`repo/xxm_fans_backend/gallery/models.py`

```python
def delete_image(self, filename):
    """删除图集中的图片"""
    folder_path = self.folder_path.lstrip('/')
    file_path = os.path.join(folder_path, filename)

    if default_storage.exists(file_path):
        # 自动删除缩略图（通过信号处理）
        from core.thumbnail_generator import ThumbnailGenerator
        ThumbnailGenerator.delete_thumbnail(file_path)
        
        default_storage.delete(file_path)
        self.refresh_image_count()
        return True

    return False
```

#### 3.4.4 更新 models.py 的 update_cover 方法

**文件路径**：`repo/xxm_fans_backend/gallery/models.py`

```python
def update_cover(self, cover_file):
    """更新封面图片"""
    folder_path = self.folder_path.lstrip('/')

    # 确保文件夹存在
    if not default_storage.exists(folder_path):
        default_storage.makedirs(folder_path)

    # 保存封面
    cover_path = os.path.join(folder_path, 'cover.jpg')
    default_storage.save(cover_path, cover_file)

    # 自动生成缩略图（通过信号处理）
    from core.thumbnail_generator import ThumbnailGenerator
    ThumbnailGenerator.generate_thumbnail(cover_path)

    # 更新封面 URL（保存原图路径）
    self.cover_url = f"{self.folder_path}cover.jpg"
    self.save()

#### 3.4.5 添加封面缩略图 URL 方法

**文件路径**：`repo/xxm_fans_backend/gallery/models.py`

```python
class Gallery(models.Model):
    # ... 现有字段和方法 ...
    
    def get_cover_thumbnail_url(self):
        """获取封面缩略图 URL"""
        if not self.cover_url:
            return None
        
        from core.thumbnail_generator import ThumbnailGenerator
        return ThumbnailGenerator.get_thumbnail_url(self.cover_url)
```

**API 返回格式**：

```python
# gallery 视图中
@api_view(['GET'])
def gallery_detail(request, gallery_id):
    gallery = Gallery.objects.get(id=gallery_id)
    return success_response({
        'cover_url': gallery.cover_url,  # 原图（图集详情展示）
        'cover_thumbnail_url': gallery.get_cover_thumbnail_url(),  # 缩略图（封面列表展示）
        # ... 其他字段
    })
```

### 3.5 更新 song_management 模块

**文件路径**：`repo/xxm_fans_backend/song_management/models/song.py`

```python
from django.db import models
from django.core.files.storage import default_storage

class Song(models.Model):
    # ... 现有字段 ...
    
    # 添加 cover_url 字段（如果还没有）
    cover_url = models.CharField(
        max_length=500,
        blank=True,
        verbose_name='封面图片URL'
    )
    
    def get_cover_thumbnail_url(self):
        """获取封面缩略图 URL"""
        if not self.cover_url:
            return None
        
        from core.thumbnail_generator import ThumbnailGenerator
        return ThumbnailGenerator.get_thumbnail_url(self.cover_url)
```

### 3.6 更新 fansDIY 模块

**文件路径**：`repo/xxm_fans_backend/fansDIY/models.py`

```python
from django.db import models

class Work(models.Model):
    # ... 现有字段 ...
    
    cover_url = models.CharField(
        max_length=500,
        verbose_name='封面图片URL'
    )
    
    def get_cover_thumbnail_url(self):
        """获取封面缩略图 URL"""
        if not self.cover_url:
            return None
        
        from core.thumbnail_generator import ThumbnailGenerator
        return ThumbnailGenerator.get_thumbnail_url(self.cover_url)
```

### 3.7 更新 songlist 模块

**文件路径**：`repo/xxm_fans_backend/songlist/models.py`

```python
def create_artist_models(artist_key, artist_name):
    """同时创建歌手的Song和SiteSetting模型"""
    class_name = artist_key.capitalize()

    # 创建Song模型
    class SongMeta:
        verbose_name = f'{artist_name}歌曲'
        verbose_name_plural = f'{artist_name}歌曲'
        app_label = 'songlist'
        ordering = ['song_name']

    song_attrs = {
        '__module__': 'songlist.models',
        'song_name': models.CharField(max_length=200, verbose_name='歌曲名称'),
        'singer': models.CharField(max_length=100, verbose_name='原唱歌手'),
        'language': models.CharField(max_length=50, verbose_name='语言'),
        'style': models.CharField(max_length=50, verbose_name='曲风'),
        'note': models.TextField(blank=True, verbose_name='备注'),
        'Meta': SongMeta,
        '__str__': lambda self: self.song_name,
    }

    song_model = type(f'{class_name}Song', (models.Model,), song_attrs)

    # 创建SiteSetting模型
    class SettingMeta:
        verbose_name = f'{artist_name}网站设置'
        verbose_name_plural = f'{artist_name}网站设置'
        app_label = 'songlist'

    setting_attrs = {
        '__module__': 'songlist.models',
        'photo': models.ImageField(
            upload_to=f'songlist/{artist_key}/',
            verbose_name='图片',
            blank=True,
            null=True
        ),
        'photo_url': models.CharField(
            max_length=500,
            verbose_name='图片URL',
            blank=True,
            help_text='如果上传了图片，此字段将自动填充'
        ),
        'position': models.IntegerField(
            verbose_name='位置',
            choices=[
                (1, '头像图标'),
                (2, '背景图片'),
            ]
        ),
        'Meta': SettingMeta,
        '__str__': lambda self: f"设置 - 位置: {self.get_position_display()}",
    }

    def _get_photo_thumbnail_url(self):
        """获取图片缩略图 URL"""
        # songlist 模块不使用缩略图，直接返回原图
        if not self.photo:
            return self.photo_url or None
        return self.photo.url

    setting_attrs['get_photo_thumbnail_url'] = _get_photo_thumbnail_url

    setting_model = type(f'{class_name}SiteSetting', (models.Model,), setting_attrs)

    return song_model, setting_model
```

### 3.8 创建管理命令

#### 3.8.1 批量生成缩略图命令

**文件路径**：`repo/xxm_fans_backend/core/management/commands/generate_thumbnails.py`

```python
from django.core.management.base import BaseCommand
from core.thumbnail_generator import ThumbnailGenerator


class Command(BaseCommand):
    help = '批量生成缩略图'

    def add_arguments(self, parser):
        parser.add_argument(
            '--module',
            type=str,
            help='指定模块（gallery/covers/footprint/songlist），不指定则全部生成'
        )
        parser.add_argument(
            '--force',
            action='store_true',
            help='强制重新生成所有缩略图'
        )

    def handle(self, *args, **options):
        module = options.get('module')
        force = options.get('force')

        self.stdout.write('开始批量生成缩略图...')

        if force:
            self.stdout.write('⚠️  强制重新生成模式')
        
        ThumbnailGenerator.batch_generate_thumbnails(module)

        self.stdout.write(self.style.SUCCESS('完成！'))
```

#### 3.8.2 清理孤立缩略图命令

**文件路径**：`repo/xxm_fans_backend/core/management/commands/cleanup_thumbnails.py`

```python
from django.core.management.base import BaseCommand
from core.thumbnail_generator import ThumbnailGenerator


class Command(BaseCommand):
    help = '清理孤立的缩略图（原图已不存在的缩略图）'

    def handle(self, *args, **options):
        self.stdout.write('开始清理孤立缩略图...')

        ThumbnailGenerator.cleanup_orphan_thumbnails()

        self.stdout.write(self.style.SUCCESS('完成！'))
```

### 3.9 更新 B 站封面下载工具

**文件路径**：`repo/xxm_fans_backend/tools/bilibili/cover_downloader.py`

在下载封面后自动生成缩略图：

```python
from core.thumbnail_generator import ThumbnailGenerator

def download_bilibili_cover(bvid: str, sub_path: str = None) -> str:
    """从 B 站下载封面图片并自动生成缩略图
    
    Args:
        bvid: B 站视频 BV 号
        sub_path: 子路径（如 'covers/2025/01' 或 'footprint/Collection'）
    
    Returns:
        本地相对路径，失败返回 None
    """
    # ... 现有下载逻辑 ...
    
    # 下载成功后自动生成缩略图
    if local_path and default_storage.exists(local_path):
        try:
            thumbnail_path = ThumbnailGenerator.generate_thumbnail(local_path)
            print(f"✓ 自动生成缩略图: {thumbnail_path}")
        except Exception as e:
            print(f"✗ 生成缩略图失败: {e}")
    
    return local_path
```

**文件路径**：`repo/xxm_fans_backend/tools/cover_downloader.py`

```python
from core.thumbnail_generator import ThumbnailGenerator

def download_cover(bvid: str, year: int, month: int) -> str:
    """下载封面并自动生成缩略图"""
    # ... 现有下载逻辑 ...
    
    # 下载成功后自动生成缩略图
    if local_path:
        try:
            ThumbnailGenerator.generate_thumbnail(local_path)
            print(f"✓ 自动生成缩略图: {local_path}")
        except Exception as e:
            print(f"✗ 生成缩略图失败: {e}")
    
    return local_path
```

### 3.10 更新 API 视图

#### 3.9.1 更新 song_management API

**文件路径**：`repo/xxm_fans_backend/song_management/api/views.py`

```python
@api_view(['GET'])
def song_list(request):
    """获取歌曲列表"""
    # ... 现有代码 ...
    
    # 在返回数据时同时返回原图和缩略图 URL
    for song in songs:
        song_data = {
            # ... 其他字段 ...
            'cover_url': song.cover_url,  # 原图（详情查看）
            'cover_thumbnail_url': song.get_cover_thumbnail_url(),  # 缩略图（封面展示）
        }
        results.append(song_data)
    
    # ... 返回响应 ...
```

#### 3.9.2 更新 fansDIY API

**文件路径**：`repo/xxm_fans_backend/fansDIY/api/views.py`

```python
@api_view(['GET'])
def work_list(request):
    """获取作品列表"""
    # ... 现有代码 ...
    
    # 在返回数据时同时返回原图和缩略图 URL
    for work in works:
        work_data = {
            # ... 其他字段 ...
            'cover_url': work.cover_url,  # 原图（详情查看）
            'cover_thumbnail_url': work.get_cover_thumbnail_url(),  # 缩略图（封面展示）
        }
        results.append(work_data)
    
    # ... 返回响应 ...
```

### 3.10 前端适配

#### 3.10.1 更新类型定义

**文件路径**：`repo/xxm_fans_frontend/domain/types.ts`

```typescript
// 为所有图片资源类型添加封面缩略图 URL 字段
export interface Song {
  id: string;
  name: string;
  artist: string;
  coverUrl?: string;  // 原图（详情查看）
  coverThumbnailUrl?: string;  // 缩略图（封面展示）
  // ... 其他字段
}

export interface FansDIYWork {
  id: string;
  title: string;
  coverUrl?: string;  // 原图（详情查看）
  coverThumbnailUrl?: string;  // 缩略图（封面展示）
  // ... 其他字段
}

export interface Gallery {
  id: string;
  title: string;
  coverUrl?: string;  // 原图（详情查看）
  coverThumbnailUrl?: string;  // 缩略图（封面展示）
  // ... 其他字段
}

export interface GalleryImage {
  id: string;
  url: string;  // 原图（放大查看）
  thumbnailUrl?: string;  // 缩略图（列表展示）
  title: string;
  // ... 其他字段
}
```

#### 3.10.2 更新图片组件

在所有图片展示组件中，优先使用缩略图：

```typescript
// 封面展示
<img
  src={gallery.coverThumbnailUrl || gallery.coverUrl}
  alt={gallery.title}
  loading="lazy"
  onClick={() => handleGalleryClick(gallery)}  // 点击查看详情（使用原图）
/>

// 图集图片列表展示
<img
  src={img.thumbnailUrl || img.url}
  alt={img.title}
  loading="lazy"
  onClick={() => handleImageClick(img)}  // 点击放大查看（使用原图）
/>

// 详情查看（使用原图）
<img
  src={img.url}
  alt={img.title}
/>
  loading="lazy"
  onClick={() => handleImageClick(song)}  // 点击查看原图
/>

// 详情查看
<img
  src={song.coverUrl}  // 详情页使用原图
  alt={song.name}
/>
```

---

## 四、使用说明

### 4.1 初始化缩略图

首次部署后，批量生成所有现有图片的缩略图：

```bash
cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend

# 生成所有模块的缩略图
python manage.py generate_thumbnails

# 只生成 gallery 模块的缩略图
python manage.py generate_thumbnails --module gallery

# 强制重新生成所有缩略图
python manage.py generate_thumbnails --force
```

### 4.2 清理孤立缩略图

定期清理不再需要的缩略图：

```bash
cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend

python manage.py cleanup_thumbnails
```

### 4.3 自动化操作

#### 上传图片
- 任何方式上传图片（Django Admin、API 上传等）
- Django 信号自动触发缩略图生成
- 无需手动操作

#### 更新图片
- 任何方式更新图片（Django Admin、API 更新等）
- Django 信号自动检测图片是否更新（基于文件修改时间）
- 如果原图已更新，自动重新生成缩略图
- 无需手动操作

#### 删除图片
- 任何方式删除图片（Django Admin、API 删除等）
- Django 信号自动触发缩略图删除
- 无需手动操作

#### 注意事项
- **同名文件更新**：如果更换了图片但文件名不变，系统会自动检测文件修改时间并重新生成缩略图
- **批量更新**：批量更新图片时，每张图片都会独立检测并更新对应的缩略图
- **性能影响**：文件修改时间检测非常快速，对性能影响极小

### 4.4 定时任务（可选）

设置定时任务定期清理孤立缩略图：

**文件路径**：`scripts/cleanup_thumbnails_cron.sh`

```bash
#!/bin/bash
# 定期清理孤立缩略图

cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend
source venv/bin/activate

python manage.py cleanup_thumbnails

echo "缩略图清理完成: $(date)"
```

添加到 crontab（每月执行一次）：
```bash
0 0 1 * * /home/yifeianyi/Desktop/xxm_fans_home/scripts/cleanup_thumbnails_cron.sh >> /var/log/thumbnail_cleanup.log 2>&1
```

---

## 五、实施计划

### 5.1 阶段一：核心功能开发（2-3 天）
1. ✅ 创建通用缩略图生成器
2. ✅ 创建 Django 信号处理器
3. ✅ 注册信号
4. ✅ 创建管理命令

### 5.2 阶段二：模块集成（2-3 天）
1. ✅ 更新 gallery 模块
2. ✅ 更新 song_management 模块
3. ✅ 更新 fansDIY 模块
4. ✅ 更新 songlist 模块

### 5.3 阶段三：API 和前端适配（1-2 天）
1. ✅ 更新 API 视图
2. ✅ 更新前端类型定义
3. ✅ 更新前端图片组件

### 5.4 阶段四：测试与优化（1-2 天）
1. 功能测试
2. 性能测试
3. 自动化测试
4. 边界情况处理

### 5.5 阶段五：部署与迁移（1 天）
1. 批量生成现有图片缩略图
2. 部署到生产环境
3. 监控运行状态
4. 优化性能参数

---

## 六、优化效果预期

### 6.1 带宽优化
| 模块 | 图片数量 | 原图大小 | 缩略图大小 | 节省 |
|------|---------|---------|-----------|------|
| gallery | 310 | 647MB | ~15MB | 97.7% |
| covers | ~100 | ~200MB | ~5MB | 97.5% |
| footprint | ~50 | ~100MB | ~2.5MB | 97.5% |
| songlist | ~20 | ~40MB | 不压缩 | 0% |
| **总计** | **~480** | **~987MB** | **~22.5MB** | **97.7%** |

### 6.2 性能提升
- **首屏加载时间**：从 5-10 秒降至 1-2 秒
- **图片加载速度**：提升 10-20 倍
- **用户体验**：即时响应，无等待感

### 6.3 成本节约
- **CDN 流量成本**：降低 95% 以上
- **服务器带宽**：大幅减少带宽占用
- **存储成本**：增加约 23.5MB（约 2.4%）

---

## 七、注意事项

### 7.1 存储空间
- 缩略图将占用额外存储空间（约 23.5MB）
- 建议定期检查存储空间使用情况
- 使用 `cleanup_thumbnails` 命令清理孤立缩略图

### 7.2 生成性能
- 首次访问时需要实时生成，可能会有 100-500ms 延迟
- 建议在低峰期执行批量生成命令
- 对于大量图片上传，考虑使用异步任务队列（Celery）

### 7.3 GIF 处理
- GIF 缩略图只显示第一帧
- 如果需要展示动态效果，点击后加载原图
- 考虑为 GIF 提供特殊的缩略图策略

### 7.4 缓存策略
- 缩略图永久存储，除非原图被删除
- HTTP 缓存设置为 1 年
- 如需强制更新缩略图，可使用 `--force` 参数或删除对应缩略图文件

### 7.5 自动更新检测
- 系统会自动比较原图和缩略图的修改时间
- 如果原图比缩略图新，自动重新生成缩略图
- 支持同名文件更新（文件名不变但内容改变）
- 文件修改时间检测性能开销极小，几乎无影响

### 7.6 兼容性
- 向后兼容：如果缩略图生成失败，自动降级到原图
- 前端兼容：如果 `thumbnailUrl` 不存在，使用 `url`
- API 兼容：新增 `thumbnailUrl` 字段，不影响现有字段

### 7.7 监控
- 监控缩略图生成失败率
- 监控缩略图存储空间使用情况
- 监控缩略图访问频率和命中率
- 监控自动更新触发的频率

### 7.5 兼容性
- 向后兼容：如果缩略图生成失败，自动降级到原图
- 前端兼容：如果 `thumbnailUrl` 不存在，使用 `url`
- API 兼容：新增 `thumbnailUrl` 字段，不影响现有字段

### 7.6 监控
- 监控缩略图生成失败率
- 监控缩略图存储空间使用情况
- 监控缩略图访问频率和命中率

---

## 八、风险评估与应对

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|----------|
| 缩略图生成失败 | 功能降级到原图 | 低 | 异常捕获 + 降级方案 |
| 存储空间不足 | 无法生成新缩略图 | 低 | 定期监控 + 清理策略 |
| 性能影响（首次生成） | 用户等待时间增加 | 中 | 批量预生成 + 异步处理 |
| GIF 动画丢失 | 缩略图不显示动画 | 低 | 文档说明 + 点击查看原图 |
| 自动更新检测失败 | 缩略图未及时更新 | 低 | 异常捕获 + 降级到原图 |
| 信号处理器失效 | 自动化功能失效 | 低 | 单元测试 + 集成测试 |
| 信号处理器失效 | 自动化功能失效 | 低 | 单元测试 + 集成测试 |
| 缩略图缓存失效 | 重复生成缩略图 | 中 | 文件存在检查 + 缓存策略 |

---

## 九、扩展优化（可选）

### 9.1 多尺寸缩略图
根据不同场景生成多种尺寸：
```python
THUMBNAIL_SIZES = {
    'gallery': {
        'small': (200, 200),
        'medium': (400, 400),
        'large': (800, 800),
    },
}
```

### 9.2 WebP 自动降级
检测浏览器支持情况，不支持时返回 JPEG：
```python
def get_thumbnail_url(cls, original_url: str, format: str = 'webp') -> str:
    # 根据请求头 Accept 判断支持的格式
    # 生成对应格式的缩略图
```

### 9.3 CDN 集成
将缩略图存储到 CDN：
```python
# 使用 CDN 存储后端
CDN_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
```

### 9.4 异步生成
使用 Celery 异步生成缩略图：
```python
from celery import shared_task

@shared_task
def generate_thumbnail_async(file_path):
    ThumbnailGenerator.generate_thumbnail(file_path)
```

### 9.5 智能裁剪
根据图片内容智能裁剪缩略图：
```python
# 使用 smartcrop 库
from smartcrop import detect_crop

def smart_crop_thumbnail(img, size):
    crop = detect_crop(img, size)
    img = img.crop(crop)
    img.thumbnail(size, Image.Resampling.LANCZOS)
    return img
```

---

## 十、总结

本方案通过 **Django 信号 + 统一缩略图生成器** 实现全站缩略图自动化功能，具有以下优势：

1. **全站统一**：所有图片模块都支持缩略图
2. **完全自动化**：上传/删除图片时自动处理缩略图
3. **按需使用**：列表展示用缩略图，详情查看用原图
4. **易于维护**：代码结构清晰，扩展性强
5. **性能优秀**：带宽节省 97% 以上，加载速度提升 10-20 倍
6. **成本可控**：减少 CDN 流量成本，优化服务器资源

建议按照实施计划逐步推进，确保系统稳定性和用户体验。

---

## 附录

### A. 缩略图文件路径示例

| 原图路径 | 缩略图路径 |
|---------|-----------|
| `gallery/album1/photo1.jpg` | `thumbnails/gallery/album1/photo1.webp` |
| `gallery/album1/subdir/photo2.png` | `thumbnails/gallery/album1/subdir/photo2.webp` |
| `covers/2025/01/2025-01-15.jpg` | `thumbnails/covers/2025/01/2025-01-15.webp` |
| `footprint/Collection/work1.png` | `thumbnails/footprint/Collection/work1.webp` |
| `songlist/youyou/avatar.jpg` | 不生成缩略图 |

### B. 常用命令速查

```bash
# 批量生成所有缩略图（gallery、covers、footprint）
python manage.py generate_thumbnails

# 生成指定模块的缩略图
python manage.py generate_thumbnails --module gallery
python manage.py generate_thumbnails --module covers
python manage.py generate_thumbnails --module footprint

# 强制重新生成所有缩略图
python manage.py generate_thumbnails --force

# 清理孤立缩略图
python manage.py cleanup_thumbnails
```

### C. 配置参数说明

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `THUMBNAIL_SIZES` | 见上文 | 各模块缩略图尺寸配置（不含 songlist） |
| `QUALITY` | 85 | JPEG/WEBP 质量参数 |
| `THUMBNAIL_DIR` | `thumbnails/` | 缩略图根目录 |

### D. 故障排查

**问题：缩略图没有自动生成**
- 检查信号是否正确注册
- 检查模型是否有 ImageField
- 检查日志是否有错误信息

**问题：缩略图生成失败**
- 检查原图是否存在
- 检查文件格式是否支持
- 检查存储权限是否正确

**问题：更新图片后缩略图没有更新**
- 检查文件修改时间是否正确（原图比缩略图新）
- 检查信号是否正确触发
- 查看日志是否有"检测到原图已更新"的提示
- 尝试使用 `--force` 参数强制重新生成

**问题：缩略图没有自动删除**
- 检查 pre_delete 信号是否触发
- 检查缩略图路径是否正确
- 检查删除权限是否正确