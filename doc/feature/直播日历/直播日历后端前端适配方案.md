# 直播日历功能 - 后端接口适配方案

## 一、方案概述

本方案基于现有数据（`live_final.json`、演唱记录、图集数据）设计后端接口，为前端直播日历页面提供数据支持。

### 1.1 数据存储结构

#### 1.1.1 Livestream 数据库模型

**表名**: `livestream`

**字段说明**:

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| id | Integer | 主键（自动生成） | 1 |
| date | DateField | 直播日期（唯一索引） | 2025-11-30 |
| title | CharField(200) | 直播标题 | 咻咻满-2025年11月30日-录播 |
| summary | TextField | 直播简介 | 高能之夜，合同到期前的最后一集全程高能 |
| bvid | CharField(20) | B站视频BV号 | BV1TESqBzEyr |
| duration_seconds | Integer | 直播时长（秒） | 11090 |
| duration_formatted | CharField(50) | 直播时长（格式化） | 3h4m50s |
| parts | Integer | 视频分段数（用于前端生成播放链接） | 1 |
| live_moment | CharField(500) | LiveMoment 图册目录路径 | /gallery/LiveMoment/2025/11/30/ |
| view_count | CharField(50) | 观看人数 | 1.2万 |
| danmaku_count | CharField(50) | 弹幕数 | 3.5万 |
| start_time | TimeField | 开播时间 | 20:00:00 |
| end_time | TimeField | 下播时间 | 23:30:00 |
| danmaku_cloud_url | CharField(500) | 弹幕云图URL | /media/danmaku/2025-11-30-cloud.png |
| is_active | BooleanField | 是否启用 | True |
| sort_order | Integer | 排序 | 0 |
| created_at | DateTimeField | 创建时间 | 2025-11-30 20:00:00 |
| updated_at | DateTimeField | 更新时间 | 2025-11-30 23:30:00 |

**索引**:
- `date` - 日期索引（唯一）
- `-(date)` - 降序日期索引

**关联数据**:
- `SongRecord` - 通过 `performed_at` 字段关联，获取当日歌切列表
- `live_moment` - 直接存储 LiveMoment 图册目录路径，获取该目录下所有图片作为直播截图

#### 1.1.2 live_final.json 文件结构（Fallback 数据源）

```json
[
  {
    "bvid": "BV1TESqBzEyr",
    "date": "2025-11-30",
    "title": "咻咻满-2025年11月30日-录播",
    "duration": 11090,
    "describe": "高能之夜，合同到期前的最后一集全程高能",
    "duration_formatted": "3h4m50s",
    "parts": 1
  }
]
```

**文件路径**: `/home/yifeianyi/Desktop/xxm_fans_home/live_final.json`

**用途**: 作为数据导入源和 Fallback 数据源（当数据库无数据时使用）

#### 1.1.3 数据流转关系

```
live_final.json (导入源)
        ↓
    数据导入脚本
        ↓
    Livestream 数据库表
        ↓
    LivestreamService (业务逻辑)
        ↓
    API 接口
        ↓
    前端 LivestreamPage
```

**关联数据聚合**:
- `Livestream.date` → `SongRecord.performed_at` → 获取歌切列表
- `Livestream.live_moment` → 直接读取目录下的所有图片 → 获取直播截图列表

### 1.2 数据源分析

#### 1.2.1 live_final.json 数据结构
```json
{
  "bvid": "BV1TESqBzEyr",
  "date": "2025-11-30",
  "title": "咻咻满-2025年11月30日-录播",
  "duration": 11090,
  "describe": "高能之夜，合同到期前的最后一集全程高能",
  "duration_formatted": "3h4m50s",
  "parts": 1
}
```

#### 1.2.2 现有数据模型
- **SongRecord**: 演唱记录（通过 `performed_at` 关联日期）
- **Gallery**: 图集数据（通过 `folder_path` 或 `title` 中的日期信息关联）

#### 1.2.3 前端数据需求
```typescript
interface Livestream {
  id: string;                          // 日期字符串 (YYYY-MM-DD)
  date: string;                        // 日期
  title: string;                       // 直播标题
  summary: string;                     // 直播简介
  viewCount: string;                   // 观看人数
  danmakuCount: string;                // 弹幕数
  startTime: string;                   // 开播时间
  endTime: string;                     // 下播时间
  duration: string;                    // 直播时长
  recordings: LivestreamRecording[];   // 完整回放录像（前端根据 bvid 和 parts 生成）
  songCuts: SongCut[];                 // 歌切列表
  screenshots: string[];               // 直播截图（从 live_moment 目录获取）
  danmakuCloudUrl: string;             // 弹幕云图
  bvid: string;                        // B站视频BV号
  parts: number;                       // 视频分段数
}

interface LivestreamRecording {
  title: string;
  url: string;  // 前端根据 bvid + p 参数生成
}

interface SongCut {
  id: number;       // 演唱记录ID，可用于跳转到详情页
  name: string;     // 歌曲名称
  videoUrl: string; // 演唱记录链接（B站视频链接）
}
```

---

## 二、后端接口适配方案

### 2.1 数据模型设计

#### 2.1.1 Livestream 模型

虽然本方案主要使用虚拟聚合数据，但为了更好的数据管理和扩展性，建议创建 `Livestream` 模型来存储直播基本信息。

**文件**: `livestream/models.py`

```python
from django.db import models


class Livestream(models.Model):
    """直播记录模型 - 存储直播基本信息"""

    # 基础信息
    date = models.DateField(
        unique=True,
        verbose_name='直播日期',
        help_text='直播日期，格式：YYYY-MM-DD'
    )
    title = models.CharField(
        max_length=200,
        verbose_name='直播标题',
        help_text='直播标题，如：咻咻满-2025年11月30日-录播'
    )
    summary = models.TextField(
        blank=True,
        verbose_name='直播简介',
        help_text='直播简介或描述'
    )

    # B站视频信息
    bvid = models.CharField(
        max_length=20,
        blank=True,
        null=True,
        verbose_name='B站视频BV号',
        help_text='B站视频的BV号'
    )
    duration_seconds = models.IntegerField(
        blank=True,
        null=True,
        verbose_name='直播时长（秒）',
        help_text='直播总时长，单位：秒'
    )
    duration_formatted = models.CharField(
        max_length=50,
        blank=True,
        verbose_name='直播时长（格式化）',
        help_text='格式化后的时长，如：3h4m50s'
    )
    parts = models.IntegerField(
        default=1,
        verbose_name='视频分段数',
        help_text='B站视频的分段数，用于前端生成播放链接'
    )

    # LiveMoment 图册目录
    live_moment = models.CharField(
        max_length=500,
        blank=True,
        verbose_name='LiveMoment 图册目录',
        help_text='LiveMoment 图册目录路径，如：/gallery/LiveMoment/2025/11/30/'
    )

    # 统计数据（预留字段）
    view_count = models.CharField(
        max_length=50,
        blank=True,
        default='N/A',
        verbose_name='观看人数',
        help_text='观看人数，如：1.2万'
    )
    danmaku_count = models.CharField(
        max_length=50,
        blank=True,
        default='N/A',
        verbose_name='弹幕数',
        help_text='弹幕总数，如：3.5万'
    )

    # 时间信息（预留字段）
    start_time = models.TimeField(
        blank=True,
        null=True,
        verbose_name='开播时间',
        help_text='开播时间，如：20:00:00'
    )
    end_time = models.TimeField(
        blank=True,
        null=True,
        verbose_name='下播时间',
        help_text='下播时间，如：23:30:00'
    )

    # 弹幕云图（预留字段）
    danmaku_cloud_url = models.CharField(
        max_length=500,
        blank=True,
        verbose_name='弹幕云图URL',
        help_text='弹幕云图分析结果图片URL'
    )

    # 元数据
    is_active = models.BooleanField(
        default=True,
        verbose_name='是否启用',
        help_text='是否在直播日历中显示'
    )
    sort_order = models.IntegerField(
        default=0,
        verbose_name='排序',
        help_text='排序字段，数字越小越靠前'
    )

    # 时间戳
    created_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name='创建时间'
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        verbose_name='更新时间'
    )

    class Meta:
        db_table = 'livestream'
        verbose_name = '直播记录'
        verbose_name_plural = '直播记录'
        ordering = ['-date', '-sort_order']
        indexes = [
            models.Index(fields=['date']),
            models.Index(fields=['-date']),
        ]

    def __str__(self):
        return f"{self.date} - {self.title}"

    def get_bilibili_url(self):
        """获取 B站视频 URL"""
        if self.bvid:
            return f'https://www.bilibili.com/video/{self.bvid}'
        return ''

    def get_song_cuts(self):
        """获取当日歌切列表"""
        from song_management.models import SongRecord

        song_records = SongRecord.objects.filter(
            performed_at=self.date
        ).select_related('song').order_by('song__song_name')

        return [{
            'id': record.id,  # 演唱记录ID，可用于跳转到详情页
            'name': record.song.song_name,
            'videoUrl': record.url or '',  # 演唱记录链接（B站视频链接）
        } for record in song_records]

    def get_screenshots(self):
        """获取直播截图列表（从 live_moment 目录）"""
        from django.core.files.storage import default_storage

        if not self.live_moment:
            return []

        folder_path = self.live_moment.lstrip('/')

        try:
            # 检查目录是否存在
            if not default_storage.exists(folder_path):
                return []

            # 获取目录下所有图片文件
            files = default_storage.listdir(folder_path)[1] if hasattr(default_storage, 'listdir') else []

            image_files = sorted([
                f for f in files
                if f.lower().endswith(('.jpg', '.jpeg', '.png', '.webp', '.gif'))
            ])

            # 返回完整的图片 URL 列表
            return [f"{self.live_moment}{f}" for f in image_files]
        except Exception:
            return []

    def to_dict(self):
        """转换为字典格式（用于 API 返回）"""
        screenshots = self.get_screenshots()

        return {
            'id': self.date.strftime('%Y-%m-%d'),
            'date': self.date.strftime('%Y-%m-%d'),
            'title': self.title,
            'summary': self.summary or f'{self.date} 的精彩直播时刻',
            'viewCount': self.view_count,
            'danmakuCount': self.danmaku_count,
            'startTime': self.start_time.strftime('%H:%M') if self.start_time else 'N/A',
            'endTime': self.end_time.strftime('%H:%M') if self.end_time else 'N/A',
            'duration': self.duration_formatted or 'N/A',
            'bvid': self.bvid or '',
            'parts': self.parts,
            'recordings': [],  # 前端根据 bvid 和 parts 生成
            'songCuts': self.get_song_cuts(),
            'screenshots': screenshots,
            'danmakuCloudUrl': self.danmaku_cloud_url or '',
        }
```

#### 2.1.2 数据库迁移

创建模型后，需要执行数据库迁移：

```bash
cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend
python manage.py makemigrations livestream
python manage.py migrate livestream
```

#### 2.1.3 Admin 配置

**文件**: `livestream/admin.py`

```python
from django.contrib import admin
from .models import Livestream


@admin.register(Livestream)
class LivestreamAdmin(admin.ModelAdmin):
    """直播记录管理后台"""

    list_display = [
        'date',
        'title',
        'duration_formatted',
        'view_count',
        'danmaku_count',
        'is_active',
        'created_at'
    ]
    list_filter = ['is_active', 'date']
    search_fields = ['title', 'summary', 'bvid']
    date_hierarchy = 'date'
    ordering = ['-date']

    fieldsets = (
        ('基础信息', {
            'fields': ('date', 'title', 'summary', 'live_moment', 'is_active', 'sort_order')
        }),
        ('B站视频信息', {
            'fields': ('bvid', 'duration_seconds', 'duration_formatted', 'parts')
        }),
        ('统计数据', {
            'fields': ('view_count', 'danmaku_count')
        }),
        ('时间信息', {
            'fields': ('start_time', 'end_time')
        }),
        ('弹幕云图', {
            'fields': ('danmaku_cloud_url',)
        }),
    )

    def get_queryset(self, request):
        qs = super().get_queryset(request)
        return qs.select_related()
```

### 2.2 创建 livestream 应用

#### 2.2.1 应用结构
```
livestream/
├── __init__.py
├── apps.py
├── models.py                      # 数据模型
├── admin.py                       # 后台管理
├── services/
│   └── livestream_service.py      # 核心业务逻辑
├── api/
│   ├── serializers.py             # 序列化器
│   ├── views.py                   # API 视图
│   └── urls.py                    # 路由配置
└── tests/
    └── test_livestream.py
```

#### 2.2.2 创建命令
```bash
cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend
python manage.py startapp livestream
```

### 2.3 演唱记录链接返回说明

本方案中，后端接口返回的 `songCuts` 列表包含了演唱记录的完整信息，其中包括 `videoUrl` 字段，该字段存储了演唱记录的 B站视频链接。

#### 2.3.1 数据来源

演唱记录数据来源于现有的 `SongRecord` 模型，通过 `performed_at` 字段与直播日期进行关联：

```python
# 从 SongRecord 模型获取指定日期的演唱记录
song_records = SongRecord.objects.filter(
    performed_at=date
).select_related('song').order_by('song__song_name')
```

#### 2.3.2 返回数据结构

后端返回的 `songCuts` 列表每项包含以下字段：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| id | number | 演唱记录ID，可用于跳转到详情页 | 123 |
| name | string | 歌曲名称 | "歌曲名称" |
| videoUrl | string | 演唱记录链接（B站视频链接） | "https://www.bilibili.com/video/BV1xx" |

#### 2.3.3 完整返回示例

```json
{
  "code": 200,
  "message": "获取成功",
  "data": {
    "id": "2025-11-30",
    "date": "2025-11-30",
    "title": "咻咻满-2025年11月30日-录播",
    "summary": "高能之夜，合同到期前的最后一集全程高能",
    "viewCount": "N/A",
    "danmakuCount": "N/A",
    "startTime": "N/A",
    "endTime": "N/A",
    "duration": "3h4m50s",
    "bvid": "BV1TESqBzEyr",
    "parts": 1,
    "recordings": [],
    "songCuts": [
      {
        "id": 123,
        "name": "歌曲名称1",
        "videoUrl": "https://www.bilibili.com/video/BV1xx"
      },
      {
        "id": 124,
        "name": "歌曲名称2",
        "videoUrl": "https://www.bilibili.com/video/BV1yy"
      }
    ],
    "screenshots": ["/gallery/LiveMoment/2025/11/30/001.jpg"],
    "danmakuCloudUrl": ""
  }
}
```

#### 2.3.4 前端使用方式

前端可以直接使用 `videoUrl` 字段播放歌切视频，或使用 `id` 字段跳转到演唱记录详情页：

```typescript
// 播放歌切视频
const playSongCut = (songCut: SongCut) => {
  window.open(songCut.videoUrl, '_blank');
};

// 跳转到演唱记录详情页
const goToRecordDetail = (songCut: SongCut) => {
  router.push(`/songs/${songCut.id}/records`);
};
```

### 2.4 核心服务实现

#### 2.4.1 livestream/services/livestream_service.py

```python
from django.db.models import Q
from datetime import datetime
from .models import Livestream
import json


class LivestreamService:
    """直播数据服务 - 优先使用 Livestream 模型，fallback 到 JSON 文件"""

    # 直播数据 JSON 文件路径（fallback 数据源）
    LIVE_DATA_FILE = '/home/yifeianyi/Desktop/xxm_fans_home/live_final.json'

    @classmethod
    def get_livestreams_by_month(cls, year: int, month: int):
        """
        获取指定月份的所有直播记录

        Args:
            year: 年份
            month: 月份 (1-12)

        Returns:
            List[dict]: 直播记录列表
        """
        livestreams = []

        # 优先从 Livestream 模型获取数据
        db_livestreams = Livestream.objects.filter(
            date__year=year,
            date__month=month,
            is_active=True
        ).order_by('-date')

        if db_livestreams.exists():
            # 使用数据库数据
            for livestream in db_livestreams:
                livestreams.append(livestream.to_dict())
        else:
            # Fallback: 从 JSON 文件加载数据
            livestreams = cls._get_livestreams_from_json(year, month)

        return livestreams

    @classmethod
    def get_livestream_by_date(cls, date_str: str):
        """
        获取指定日期的直播记录

        Args:
            date_str: 日期字符串 (YYYY-MM-DD)

        Returns:
            dict: 直播记录详情，如果不存在返回 None
        """
        try:
            date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            return None

        # 优先从 Livestream 模型获取数据
        try:
            livestream = Livestream.objects.get(date=date_obj, is_active=True)
            return livestream.to_dict()
        except Livestream.DoesNotExist:
            pass

        # Fallback: 从 JSON 文件获取数据
        return cls._get_livestream_from_json(date_str)

    @classmethod
    def _get_livestreams_from_json(cls, year: int, month: int):
        """从 JSON 文件获取指定月份的直播记录"""
        livestreams = []
        live_data = cls._load_live_data()

        month_data = [
            item for item in live_data
            if cls._parse_date(item.get('date', ''))
            and cls._parse_date(item['date']).year == year
            and cls._parse_date(item['date']).month == month
        ]

        for item in month_data:
            date_str = item.get('date', '')
            date_obj = cls._parse_date(date_str)

            if not date_obj:
                continue

            livestream = cls._build_livestream_from_json(date_obj, item)
            if livestream:
                livestreams.append(livestream)

        livestreams.sort(key=lambda x: x['date'], reverse=True)
        return livestreams

    @classmethod
    def _get_livestream_from_json(cls, date_str: str):
        """从 JSON 文件获取指定日期的直播记录"""
        try:
            date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            return None

        live_data = cls._load_live_data()
        matched_item = None

        for item in live_data:
            if cls._parse_date(item.get('date', '')) == date_obj:
                matched_item = item
                break

        if not matched_item:
            return None

        return cls._build_livestream_from_json(date_obj, matched_item)

    @classmethod
    def _load_live_data(cls):
        """加载 live_final.json 数据"""
        try:
            with open(cls.LIVE_DATA_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return []

    @classmethod
    def _parse_date(cls, date_str: str):
        """解析日期字符串"""
        if not date_str:
            return None
        try:
            return datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            return None

    @classmethod
    def _build_livestream_from_json(cls, date: datetime.date, live_item: dict):
        """从 JSON 数据构建直播记录"""
        date_str = date.strftime('%Y-%m-%d')

        # 获取当日歌切（演唱记录）
        song_cuts = cls._get_song_cuts_by_date(date)

        # 获取当日截图（从 LiveMoment 目录）
        screenshots = cls._get_screenshots_by_date(date)

        # 使用 live_final.json 中的标题和描述
        title = live_item.get('title', f'{date_str} 直播记录')
        summary = live_item.get('describe', f'{date_str} 的精彩直播时刻')
        duration = live_item.get('duration_formatted', 'N/A')
        bvid = live_item.get('bvid', '')
        parts = live_item.get('parts', 1)

        # 生成 live_moment 目录路径
        live_moment = f'/gallery/LiveMoment/{date.year}/{date.month:02d}/{date.day:02d}/'

        return {
            'id': date_str,
            'date': date_str,
            'title': title,
            'summary': summary,
            'viewCount': 'N/A',
            'danmakuCount': 'N/A',
            'startTime': 'N/A',
            'endTime': 'N/A',
            'duration': duration,
            'bvid': bvid,
            'parts': parts,
            'recordings': [],  # 前端根据 bvid 和 parts 生成
            'songCuts': song_cuts,
            'screenshots': screenshots,
            'danmakuCloudUrl': '',
        }

    @classmethod
    def _get_song_cuts_by_date(cls, date: datetime.date):
        """获取指定日期的歌切列表"""
        from song_management.models import SongRecord

        song_records = SongRecord.objects.filter(
            performed_at=date
        ).select_related('song').order_by('song__song_name')

        return [{
            'id': record.id,  # 演唱记录ID，可用于跳转到详情页
            'name': record.song.song_name,
            'videoUrl': record.url or '',  # 演唱记录链接（B站视频链接）
        } for record in song_records]

    @classmethod
    def _get_screenshots_by_date(cls, date: datetime.date):
        """获取指定日期的截图列表（从 LiveMoment 目录）"""
        from django.core.files.storage import default_storage

        # 生成 live_moment 目录路径
        live_moment = f'/gallery/LiveMoment/{date.year}/{date.month:02d}/{date.day:02d}/'
        folder_path = live_moment.lstrip('/')

        try:
            # 检查目录是否存在
            if not default_storage.exists(folder_path):
                return []

            # 获取目录下所有图片文件
            files = default_storage.listdir(folder_path)[1] if hasattr(default_storage, 'listdir') else []

            image_files = sorted([
                f for f in files
                if f.lower().endswith(('.jpg', '.jpeg', '.png', '.webp', '.gif'))
            ])

            # 返回完整的图片 URL 列表
            return [f"{live_moment}{f}" for f in image_files]
        except Exception:
            return []
```
        
        # 3. 为每个日期构建完整的直播记录
        for item in month_data:
            date_str = item.get('date', '')
            date_obj = cls._parse_date(date_str)
            
            if not date_obj:
                continue
            
            livestream = cls._build_livestream_record(date_obj, item)
            if livestream:
                livestreams.append(livestream)
        
        # 4. 按日期降序排序
        livestreams.sort(key=lambda x: x['date'], reverse=True)
        
        return livestreams
    
    @classmethod
    def get_livestream_by_date(cls, date_str: str):
        """
        获取指定日期的直播记录
        
        Args:
            date_str: 日期字符串 (YYYY-MM-DD)
            
        Returns:
            dict: 直播记录详情，如果不存在返回 None
        """
        try:
            date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            return None
        
        # 从 live_final.json 查找匹配的数据
        live_data = cls._load_live_data()
        matched_item = None
        
        for item in live_data:
            if cls._parse_date(item.get('date', '')) == date_obj:
                matched_item = item
                break
        
        if not matched_item:
            return None
        
        return cls._build_livestream_record(date_obj, matched_item)
    
    @classmethod
    def _parse_date(cls, date_str: str):
        """解析日期字符串"""
        if not date_str:
            return None
        try:
            return datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            return None
    
    @classmethod
    def _build_livestream_record(cls, date: datetime.date, live_item: dict) -> dict:
        """
        为指定日期构建完整的直播记录
        
        Args:
            date: 日期对象
            live_item: live_final.json 中的数据项
            
        Returns:
            dict: 直播记录
        """
        date_str = date.strftime('%Y-%m-%d')
        
        # 1. 获取当日歌切（演唱记录）
        song_cuts = cls._get_song_cuts_by_date(date)
        
        # 2. 获取当日截图（图集）
        screenshots, cover_url, title = cls._get_screenshots_by_date(date)
        
        # 3. 构建完整回放录像
        recordings = cls._build_recordings(live_item)
        
        # 4. 使用 live_final.json 中的标题和描述
        title = live_item.get('title', f'{date_str} 直播记录')
        summary = live_item.get('describe', f'{date_str} 的精彩直播时刻')
        duration = live_item.get('duration_formatted', 'N/A')
        
        # 5. 构建直播记录
        livestream = {
            'id': date_str,
            'date': date_str,
            'title': title,
            'summary': summary,
            'coverUrl': cover_url or '',
            'viewCount': 'N/A',
            'danmakuCount': 'N/A',
            'startTime': 'N/A',
            'endTime': 'N/A',
            'duration': duration,
            'recordings': recordings,
            'songCuts': song_cuts,
            'screenshots': screenshots,
            'danmakuCloudUrl': '',
        }
        
        return livestream
    
    @classmethod
    def _build_recordings(cls, live_item: dict) -> list:
        """
        构建完整回放录像列表
        
        Args:
            live_item: live_final.json 中的数据项
            
        Returns:
            list: 录像列表
        """
        bvid = live_item.get('bvid', '')
        parts = live_item.get('parts', 1)
        title = live_item.get('title', '录播')
        
        recordings = []
        
        if bvid:
            if parts == 1:
                recordings.append({
                    'title': title,
                    'url': f'https://www.bilibili.com/video/{bvid}'
                })
            else:
                # 多分段视频
                for i in range(1, parts + 1):
                    recordings.append({
                        'title': f'{title} - P{i}',
                        'url': f'https://www.bilibili.com/video/{bvid}?p={i}'
                    })
        
        return recordings
    
    @classmethod
    def _get_song_cuts_by_date(cls, date: datetime.date) -> list:
        """
        获取指定日期的歌切列表（演唱记录）

        Args:
            date: 日期对象

        Returns:
            list: 歌切列表，每项包含：
                - id: 演唱记录ID（用于跳转到详情页）
                - name: 歌曲名称
                - videoUrl: 演唱记录链接（B站视频链接）
        """
        song_records = SongRecord.objects.filter(
            performed_at=date
        ).select_related('song').order_by('song__song_name')

        song_cuts = []
        for record in song_records:
            song_cuts.append({
                'id': record.id,  # 演唱记录ID，可用于跳转到详情页
                'name': record.song.song_name,
                'videoUrl': record.url or '',  # 演唱记录链接（B站视频链接）
            })

        return song_cuts
    
    @classmethod
    def _get_screenshots_by_date(cls, date: datetime.date) -> tuple:
        """
        获取指定日期的截图列表、封面和标题
        
        Args:
            date: 日期对象
            
        Returns:
            tuple: (screenshots, cover_url, title)
        """
        date_str = date.strftime('%Y-%m-%d')
        
        # 查找匹配的图集（LiveMoment 目录下）
        galleries = Gallery.objects.filter(
            Q(folder_path__icontains='LiveMoment') |
            Q(folder_path__icontains='live_moment'),
            is_active=True
        )
        
        matched_gallery = None
        
        # 尝试多种匹配方式
        for gallery in galleries:
            # 1. 标题包含日期
            if date_str in gallery.title:
                matched_gallery = gallery
                break
            # 2. 文件夹路径包含日期
            elif date_str in gallery.folder_path:
                matched_gallery = gallery
                break
            # 3. 标题包含中文日期格式
            elif date.strftime('%Y年%m月%d日') in gallery.title:
                matched_gallery = gallery
                break
        
        if not matched_gallery:
            return [], '', ''
        
        # 获取图片列表
        images = matched_gallery.get_images()
        screenshots = [img['url'] for img in images]
        
        # 获取封面
        cover_url = matched_gallery.cover_url or ''
        
        # 获取标题
        title = matched_gallery.title
        
        return screenshots, cover_url, title
```

### 2.5 API 视图实现

#### 2.5.1 livestream/api/views.py

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from core.responses import success_response, error_response
from ..services.livestream_service import LivestreamService


class LivestreamListView(APIView):
    """获取指定月份的直播记录列表"""
    
    def get(self, request, *args, **kwargs):
        try:
            year = int(request.query_params.get('year', 2025))
            month = int(request.query_params.get('month', 1))
            
            # 参数校验
            if month < 1 or month > 12:
                return error_response(
                    message='月份参数无效，必须在 1-12 之间'
                )
            
            livestreams = LivestreamService.get_livestreams_by_month(year, month)
            
            return success_response(
                data=livestreams,
                message='获取成功'
            )
        except ValueError:
            return error_response(message='参数格式错误')
        except Exception as e:
            return error_response(message=f'获取直播记录失败: {str(e)}')


class LivestreamDetailView(APIView):
    """获取指定日期的直播记录详情"""
    
    def get(self, request, date_str, *args, **kwargs):
        try:
            livestream = LivestreamService.get_livestream_by_date(date_str)
            
            if not livestream:
                return success_response(
                    data=None,
                    message='该日期无直播记录'
                )
            
            return success_response(
                data=livestream,
                message='获取成功'
            )
        except Exception as e:
            return error_response(message=f'获取直播详情失败: {str(e)}')
```

#### 2.5.2 livestream/api/urls.py

```python
from django.urls import path
from .views import LivestreamListView, LivestreamDetailView

urlpatterns = [
    path('livestreams/', LivestreamListView.as_view(), name='livestream-list'),
    path('livestreams/<str:date_str>/', LivestreamDetailView.as_view(), name='livestream-detail'),
]
```

### 2.6 应用注册和路由配置

#### 2.6.1 在 settings.py 中注册应用

在 `repo/xxm_fans_backend/xxm_fans_home/settings.py` 中添加：

```python
INSTALLED_APPS = [
    # ... 现有应用 ...
    'livestream',
]
```

#### 2.6.2 在主路由中添加 API 路由

在 `repo/xxm_fans_backend/xxm_fans_home/urls.py` 中添加：

```python
urlpatterns = [
    # ... 现有路由 ...
    path('api/', include('livestream.api.urls')),
]
```

---

## 三、前端适配方案

### 3.1 更新 API 服务

#### 3.1.1 在 RealSongService 中添加直播相关方法

**注意**: 前端接收到的 `songCuts` 列表中包含演唱记录的完整链接信息（`videoUrl` 字段），可直接用于播放或跳转。

在 `repo/xxm_fans_frontend/infrastructure/api/RealSongService.ts` 中添加：

```typescript
/**
 * 获取指定月份的直播记录列表
 */
async getLivestreams(year: number, month: number): Promise<Livestream[]> {
  try {
    const response = await fetch(`${this.apiBase}/livestreams/?year=${year}&month=${month}`);
    const result = await response.json();
    
    if (result.code === 200) {
      return result.data;
    }
    return [];
  } catch (error) {
    console.error('获取直播记录失败:', error);
    return [];
  }
}

/**
 * 获取指定日期的直播记录详情
 */
async getLivestreamByDate(dateStr: string): Promise<Livestream | null> {
  try {
    const response = await fetch(`${this.apiBase}/livestreams/${dateStr}/`);
    const result = await response.json();
    
    if (result.code === 200 && result.data) {
      return result.data;
    }
    return null;
  } catch (error) {
    console.error('获取直播详情失败:', error);
    return null;
  }
}
```

### 3.2 更新 LivestreamPage 组件

#### 3.2.1 替换 Mock API 为真实 API

在 `repo/xxm_fans_frontend/presentation/pages/LivestreamPage.tsx` 中修改：

```typescript
// 替换导入
import { RealSongService } from '../../infrastructure/api/RealSongService';

const LivestreamPage: React.FC = () => {
  // 使用真实 API 服务
  const realApi = new RealSongService();
  
  // 在 useEffect 中使用真实 API
  useEffect(() => {
    const fetchLives = async () => {
      setLoading(true);
      const data = await realApi.getLivestreams(currentDate.getFullYear(), currentDate.getMonth() + 1);
      setLives(data);
      if (data.length > 0) {
        setSelectedLive(data[0]);
        setActiveScreenshot(data[0].screenshots[0]);
        setSelectedRecordingIndex(0);
        setViewingCloud(false);
        // 获取当天的演唱记录
        fetchSongRecords(data[0].date);
      } else {
        setSelectedLive(null);
        setSongRecords([]);
      }
      setLoading(false);
    };
    fetchLives();
  }, [currentDate]);
  
  // ... 其余代码保持不变
};
```

### 3.3 前端生成 B站视频链接

由于后端只返回 `bvid` 和 `parts`，前端需要根据这两个字段生成播放链接。

#### 3.3.1 更新类型定义

确保 `domain/types.ts` 中的类型定义包含 `bvid` 和 `parts`：

```typescript
export interface Livestream {
  id: string;
  date: string;
  title: string;
  summary: string;
  viewCount: string;
  danmakuCount: string;
  startTime: string;
  endTime: string;
  duration: string;
  bvid: string;                        // B站视频BV号
  parts: number;                       // 视频分段数
  recordings: LivestreamRecording[];   // 前端根据 bvid 和 parts 生成
  songCuts: SongCut[];
  screenshots: string[];
  danmakuCloudUrl: string;
}

export interface LivestreamRecording {
  title: string;
  url: string;
}

export interface SongCut {
  id: number;       // 演唱记录ID，可用于跳转到详情页
  name: string;     // 歌曲名称
  videoUrl: string; // 演唱记录链接（B站视频链接）
}
```

#### 3.3.2 添加视频链接生成工具函数

在 `repo/xxm_fans_frontend/shared/utils/videoUtils.ts` 中添加：

```typescript
/**
 * 生成 B站视频播放链接
 * @param bvid B站视频BV号
 * @param page 分段号（从1开始）
 * @returns 视频播放链接
 */
export function generateBilibiliUrl(bvid: string, page: number = 1): string {
  if (!bvid) return '';
  
  if (page === 1) {
    return `https://www.bilibili.com/video/${bvid}`;
  }
  
  return `https://www.bilibili.com/video/${bvid}?p=${page}`;
}

/**
 * 根据直播记录生成分段视频列表
 * @param livestream 直播记录
 * @returns 分段视频列表
 */
export function generateLivestreamRecordings(livestream: Livestream): LivestreamRecording[] {
  const { bvid, title, parts } = livestream;
  
  if (!bvid) return [];
  
  const recordings: LivestreamRecording[] = [];
  
  if (parts === 1) {
    recordings.push({
      title: title,
      url: generateBilibiliUrl(bvid, 1)
    });
  } else {
    for (let i = 1; i <= parts; i++) {
      recordings.push({
        title: `${title} - P${i}`,
        url: generateBilibiliUrl(bvid, i)
      });
    }
  }
  
  return recordings;
}

/**
 * 生成 B站播放器嵌入链接
 * @param bvid B站视频BV号
 * @param page 分段号（从1开始）
 * @returns 播放器嵌入链接
 */
export function generateBilibiliEmbedUrl(bvid: string, page: number = 1): string {
  if (!bvid) return '';
  
  return `https://player.bilibili.com/player.html?bvid=${bvid}&high_quality=1&danmaku=0&autoplay=0&page=${page}`;
}
```

#### 3.3.3 更新 LivestreamPage 组件使用生成函数

在 `repo/xxm_fans_frontend/presentation/pages/LivestreamPage.tsx` 中：

```typescript
import { generateLivestreamRecordings, generateBilibiliEmbedUrl } from '../../shared/utils/videoUtils';

const LivestreamPage: React.FC = () => {
  // ... 现有代码 ...

  // 生成当前直播的录像列表
  const recordings = useMemo(() => {
    if (!selectedLive) return [];
    return generateLivestreamRecordings(selectedLive);
  }, [selectedLive]);

  // 获取当前播放的视频 URL（用于 iframe）
  const currentVideoUrl = useMemo(() => {
    if (!selectedLive || !selectedLive.bvid) return '';
    return generateBilibiliEmbedUrl(selectedLive.bvid, selectedRecordingIndex + 1);
  }, [selectedLive, selectedRecordingIndex]);

  return (
    <>
      {/* ... 其他代码 ... */}

      {/* 完整录像播放器 */}
      <div className="aspect-video bg-black rounded-[3.5rem] overflow-hidden border-4 border-white shadow-2xl relative group">
        {currentVideoUrl ? (
          <iframe
            key={currentVideoUrl}
            src={currentVideoUrl}
            className="w-full h-full border-0"
            allowFullScreen
          ></iframe>
        ) : (
          <div className="w-full h-full flex items-center justify-center text-[#8eb69b] bg-gray-900 font-black">
            暂无回放录像
          </div>
        )}
      </div>

      {/* 多分段选择器 */}
      {recordings.length > 1 && (
        <div className="flex flex-wrap gap-3 bg-white/40 p-3 rounded-3xl border-2 border-white shadow-sm">
          <div className="flex items-center gap-2 px-3 text-[#f8b195] text-[10px] font-black uppercase tracking-widest border-r border-[#f8b195]/20 mr-1">
            <Layers size={14} /> 视频分段
          </div>
          {recordings.map((rec, idx) => (
            <button
              key={idx}
              onClick={() => setSelectedRecordingIndex(idx)}
              className={`px-4 py-2 rounded-2xl text-[11px] font-black transition-all ${
                selectedRecordingIndex === idx
                  ? 'bg-[#f8b195] text-white shadow-md'
                  : 'bg-white/60 text-[#8eb69b] hover:bg-white border border-white'
              }`}
            >
              {rec.title}
            </button>
          ))}
        </div>
      )}
    </>
  );
};
```

#### 3.3.4 去除类型定义中的 coverUrl
  endTime: string;
  duration: string;
  recordings: LivestreamRecording[];
  songCuts: SongCut[];
  screenshots: string[];
  danmakuCloudUrl: string;
}

export interface LivestreamRecording {
  title: string;
  url: string;
}

export interface SongCut {
  id: number;       // 演唱记录ID，可用于跳转到详情页
  name: string;     // 歌曲名称
  videoUrl: string; // 演唱记录链接（B站视频链接）
}
```

---

## 四、前后端联调方案

### 4.1 联调前准备

#### 4.1.1 后端准备
1. 创建 livestream 应用
2. 实现核心服务（livestream_service.py）
3. 实现 API 视图和路由
4. 确保路由注册正确

#### 4.1.2 前端准备
1. 更新 RealSongService 添加直播相关方法
2. 更新 LivestreamPage 使用真实 API
3. 确保类型定义一致

#### 4.1.3 数据准备
1. 确保 `live_final.json` 文件存在且格式正确
2. 确保数据库中有演唱记录数据（SongRecord）
3. 确保 `media/gallery/LiveMoment/` 目录下有对应的图片文件夹

### 4.2 联调步骤

#### 4.2.1 启动后端服务
```bash
cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend
python manage.py runserver 0.0.0.0:8000
```

#### 4.2.2 启动前端服务
```bash
cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_frontend
npm run dev
```

#### 4.2.3 测试 API 接口

**测试 1：获取指定月份的直播记录**
```bash
curl "http://127.0.0.1:8000/api/livestreams/?year=2025&month=11"
```

预期返回：
```json
{
  "code": 200,
  "message": "获取成功",
  "data": [
    {
      "id": "2025-11-30",
      "date": "2025-11-30",
      "title": "咻咻满-2025年11月30日-录播",
      "summary": "高能之夜，合同到期前的最后一集全程高能",
      "viewCount": "N/A",
      "danmakuCount": "N/A",
      "startTime": "N/A",
      "endTime": "N/A",
      "duration": "3h4m50s",
      "bvid": "BV1TESqBzEyr",
      "parts": 1,
      "recordings": [],
      "songCuts": [
        {
          "id": 123,
          "name": "歌曲名称1",
          "videoUrl": "https://www.bilibili.com/video/BV1xx"
        },
        {
          "id": 124,
          "name": "歌曲名称2",
          "videoUrl": "https://www.bilibili.com/video/BV1yy"
        }
      ],
      "screenshots": ["/gallery/LiveMoment/2025/11/30/001.jpg", "/gallery/LiveMoment/2025/11/30/002.jpg"],
      "danmakuCloudUrl": ""
    }
  ]
}
```

**测试 2：获取指定日期的直播详情**
```bash
curl "http://127.0.0.1:8000/api/livestreams/2025-11-30/"
```

预期返回：同上（单条记录）

**测试 3：获取不存在的日期**
```bash
curl "http://127.0.0.1:8000/api/livestreams/2025-01-01/"
```

预期返回：
```json
{
  "code": 200,
  "message": "该日期无直播记录",
  "data": null
}
```

#### 4.2.4 前端功能测试

**测试清单：**

1. **日历视图测试**
   - [ ] 页面加载正确显示当月直播记录
   - [ ] 日历网格正确标记有直播的日期
   - [ ] 切换月份正确更新数据
   - [ ] 选中日期正确显示详情

2. **详情展示测试**
   - [ ] 直播标题、描述正确显示
   - [ ] 直播时长正确显示
   - [ ] 封面图片正确加载

3. **回放录像测试**
   - [ ] 录像列表正确显示
   - [ ] 单分段视频正确播放
   - [ ] 多分段视频切换正常
   - [ ] 全屏播放功能正常

4. **歌切列表测试**
   - [ ] 歌切列表正确加载
   - [ ] 点击歌切正确播放视频
   - [ ] 歌切数量正确显示

5. **截图展示测试**
   - [ ] 截图列表正确加载
   - [ ] 截图切换功能正常
   - [ ] 缩略图导航正常

6. **边界情况测试**
   - [ ] 无直播记录的月份显示空状态
   - [ ] 无歌切记录时显示提示
   - [ ] 无截图时显示默认封面

### 4.3 联调问题排查

#### 4.3.1 常见问题

**问题 1：API 返回 404**
- 检查路由是否正确注册
- 检查 URL 路径是否正确

**问题 2：数据为空**
- 检查 `live_final.json` 文件是否存在
- 检查文件路径是否正确
- 检查数据格式是否正确

**问题 3：截图列表为空**
- 检查 `media/gallery/LiveMoment/` 目录下是否有对应的日期文件夹
- 检查文件夹路径格式是否正确（YYYY/MM/DD/）

**问题 4：歌切列表为空**
- 检查 SongRecord 数据库中是否有对应日期的记录
- 检查 `performed_at` 字段格式是否正确

#### 4.3.2 调试技巧

1. **后端调试**
   - 在 `livestream_service.py` 中添加日志
   - 使用 Django Debug Toolbar 查看 SQL 查询

2. **前端调试**
   - 在浏览器控制台查看网络请求
   - 在 RealSongService 中添加 console.log

3. **数据验证**
   - 使用 Django Admin 查看数据库数据
   - 直接查看 `live_final.json` 内容

---

## 五、后续优化建议

### 5.1 数据缓存

考虑到 API 可能会被频繁访问，建议添加缓存机制：

```python
from django.core.cache import cache

class LivestreamService:
    CACHE_TIMEOUT = 3600  # 1 小时
    
    @classmethod
    def get_livestreams_by_month(cls, year: int, month: int):
        cache_key = f'livestreams_{year}_{month}'
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return cached_data
        
        livestreams = [...]
        cache.set(cache_key, livestreams, cls.CACHE_TIMEOUT)
        return livestreams
```

### 5.2 数据导入脚本

为了方便将 `live_final.json` 数据导入到数据库，创建数据导入脚本。

#### 5.2.1 导入脚本实现

**文件**: `repo/xxm_fans_backend/tools/import_livestream_data.py`

```python
import os
import sys
import django
import json
from datetime import datetime

# 添加项目根目录到路径
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'xxm_fans_home.settings')

# 初始化 Django
django.setup()

from livestream.models import Livestream


def import_livestream_data(json_file_path: str):
    """
    从 live_final.json 导入直播数据到数据库

    Args:
        json_file_path: JSON 文件路径
    """
    print(f"开始导入直播数据: {json_file_path}")

    # 读取 JSON 文件
    try:
        with open(json_file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"错误: 文件不存在 - {json_file_path}")
        return
    except json.JSONDecodeError:
        print(f"错误: JSON 格式错误 - {json_file_path}")
        return

    # 统计信息
    total_count = len(data)
    created_count = 0
    updated_count = 0
    skipped_count = 0

    # 导入数据
    for item in data:
        date_str = item.get('date', '')
        bvid = item.get('bvid', '')
        title = item.get('title', '')
        describe = item.get('describe', '')
        duration = item.get('duration', 0)
        duration_formatted = item.get('duration_formatted', '')
        parts = item.get('parts', 1)

        # 解析日期
        try:
            date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()
        except ValueError:
            print(f"跳过无效日期: {date_str}")
            skipped_count += 1
            continue

        # 检查是否已存在
        try:
            livestream = Livestream.objects.get(date=date_obj)
            # 更新现有记录
            livestream.bvid = bvid
            livestream.title = title
            livestream.summary = describe
            livestream.duration_seconds = duration
            livestream.duration_formatted = duration_formatted
            livestream.parts = parts
            # 生成 live_moment 目录路径
            livestream.live_moment = f'/gallery/LiveMoment/{date_obj.year}/{date_obj.month:02d}/{date_obj.day:02d}/'
            livestream.save()
            updated_count += 1
            print(f"✓ 更新: {date_str} - {title}")
        except Livestream.DoesNotExist:
            # 创建新记录
            live_moment = f'/gallery/LiveMoment/{date_obj.year}/{date_obj.month:02d}/{date_obj.day:02d}/'
            Livestream.objects.create(
                date=date_obj,
                bvid=bvid,
                title=title,
                summary=describe,
                duration_seconds=duration,
                duration_formatted=duration_formatted,
                parts=parts,
                live_moment=live_moment,
            )
            created_count += 1
            print(f"+ 创建: {date_str} - {title}")

    # 输出统计信息
    print("\n" + "=" * 50)
    print("导入完成！")
    print(f"总记录数: {total_count}")
    print(f"创建记录: {created_count}")
    print(f"更新记录: {updated_count}")
    print(f"跳过记录: {skipped_count}")
    print("=" * 50)


if __name__ == '__main__':
    # JSON 文件路径
    json_file = '/home/yifeianyi/Desktop/xxm_fans_home/live_final.json'

    # 执行导入
    import_livestream_data(json_file)
```

#### 5.2.2 使用导入脚本

```bash
cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend
python tools/import_livestream_data.py
```

#### 5.2.3 导入输出示例

```
开始导入直播数据: /home/yifeianyi/Desktop/xxm_fans_home/live_final.json
+ 创建: 2025-11-30 - 咻咻满-2025年11月30日-录播
+ 创建: 2025-11-29 - 咻咻满-2025年11月29日-录播
+ 创建: 2025-11-27 - 咻咻满-2025年11月27日-录播
...

==================================================
导入完成！
总记录数: 150
创建记录: 150
更新记录: 0
跳过记录: 0
==================================================
```

### 5.3 数据库集成

**注意**: 本方案已优先使用数据库存储（Livestream 模型），`live_final.json` 仅作为数据导入源和 Fallback 数据源。

如果 `live_final.json` 数据需要频繁更新，建议：

1. 定期运行导入脚本同步数据
2. 或通过 API 接口实现数据同步
3. 使用 Django Admin 手动管理数据

### 5.4 性能优化

1. **分页支持**
   - 为月度数据添加分页参数
   - 减少单次返回的数据量

2. **图片优化**
   - 使用缩略图接口
   - 添加图片懒加载

3. **查询优化**
   - 添加数据库索引
   - 使用 select_related 减少查询次数

### 5.5 扩展功能

1. **搜索功能**
   - 支持按标题搜索直播记录
   - 支持按日期范围筛选

2. **数据统计**
   - 直播时长统计
   - 歌曲演唱频率分析

3. **用户交互**
   - 直播评论功能
   - 直播收藏功能

---

## 六、实施步骤

### 6.1 后端实施步骤

1. **创建 livestream 应用**
   ```bash
   cd /home/yifeianyi/Desktop/xxm_fans_home/repo/xxm_fans_backend
   python manage.py startapp livestream
   ```

2. **创建数据模型**
   - 编辑 `livestream/models.py` 添加 `Livestream` 模型
   - 编辑 `livestream/admin.py` 添加后台管理配置

3. **执行数据库迁移**
   ```bash
   python manage.py makemigrations livestream
   python manage.py migrate livestream
   ```

4. **导入数据**
   ```bash
   python tools/import_livestream_data.py
   ```

5. **实现核心服务**
   - 创建 `livestream/services/livestream_service.py`
   - 实现数据查询和聚合逻辑

6. **实现 API 视图**
   - 创建 `livestream/api/views.py`
   - 创建 `livestream/api/urls.py`

7. **注册应用和路由**
   - 在 `settings.py` 中注册 `livestream` 应用
   - 在 `urls.py` 中添加路由

### 6.2 前端实施步骤

1. **更新 API 服务**
   - 在 `RealSongService.ts` 中添加直播相关方法

2. **更新前端页面**
   - 将 `LivestreamPage.tsx` 中的 Mock API 替换为真实 API

3. **确保类型一致性**
   - 验证 `domain/types.ts` 中的类型定义

### 6.3 测试验证

1. **准备测试数据**
   - 确保数据库中有直播数据
   - 确保有演唱记录和图集数据

2. **测试 API 接口**
   - 测试月度数据接口
   - 测试单日详情接口

3. **测试前端功能**
   - 日历视图
   - 详情展示
   - 视频播放
   - 歌切列表
   - 截图展示

### 6.4 部署上线

1. **后端部署**
   - 运行数据库迁移
   - 收集静态文件
   - 重启服务

2. **前端部署**
   - 构建生产版本
   - 部署到服务器

## 七、总结

本方案通过以下步骤实现直播日历功能：

1. **后端接口适配**
   - 创建 livestream 应用
   - 实现核心服务聚合现有数据
   - 提供 RESTful API 接口
   - 返回演唱记录链接（videoUrl）和 ID，支持直接播放或跳转详情页

2. **前端适配**
   - 更新 RealSongService 添加直播方法
   - 修改 LivestreamPage 使用真实 API
   - 确保类型定义一致

3. **联调验证**
   - 测试 API 接口
   - 验证前端功能
   - 排查常见问题

该方案充分利用了现有数据（`live_final.json`、演唱记录、图集），无需修改核心模型结构，保持了系统的向后兼容性。

### 关键特性

- **演唱记录链接返回**: 后端接口在 `songCuts` 列表中返回每首歌曲的演唱记录链接（`videoUrl`），前端可直接播放或跳转
- **ID 字段支持**: 返回演唱记录 ID（`id`），便于前端跳转到详情页
- **数据聚合**: 自动聚合 `SongRecord` 模型中的演唱记录数据
- **灵活使用**: 前端可根据需求选择使用 `videoUrl` 直接播放，或使用 `id` 跳转到详情页